# 🤝 TDD 協作開發流程：設計師導向的團隊協作

**TDD 不只是開發方法，更是一個完整的團隊協作流程**，包含：

- 🎨 **功能設計師**: 負責功能規劃和需求分析
- 🧪 **測試工程師**: 負責測試設計和測試案例撰寫
- 💻 **實作工程師**: 負責功能實作和測試通過
- 🏗️ **重構設計師**: 負責程式碼品質改善和架構優化

## 🎯 TDD 協作核心原則

1. **工作日誌驅動**: 每個階段都有對應的工作日誌，記錄思考過程和交接資訊
2. **角色明確分工**: 每個角色有明確的職責和交付物
3. **文件化交接**: 透過工作日誌進行角色間的知識傳遞
4. **測試先行**: 絕對不在沒有測試的情況下寫程式碼
5. **品質不妥協**: 每個階段都有品質門檻，不達標不進入下一階段

## 🔄 TDD 完整協作流程

TDD 協作流程分為四個明確的階段，每個階段都有專門的角色負責：

### 🎨 Phase 1: 功能設計師 - 需求分析與功能規劃

**負責角色**: 功能設計師  
**目標**: 建立清楚的功能需求和設計規範，為後續測試和實作奠定基礎

**必須建立新工作日誌**: `docs/work-logs/vX.X.X-feature-design.md`

**工作日誌必須包含內容**:

```markdown
## 功能設計規劃

### 功能需求分析：

- 這個功能要解決什麼問題？
- 使用者的具體使用場景是什麼？
- 功能的核心價值和期望效果是什麼？

### 功能規格設計：

- 功能的輸入是什麼？（參數、資料、使用者互動）
- 功能的輸出是什麼？（回傳值、副作用、使用者回饋）
- 正常流程的步驟是什麼？
- 異常情況的處理方式是什麼？

### 邊界條件分析：

- 極端輸入情況（空值、超大值、無效值）
- 系統限制和約束條件
- 錯誤情況和例外狀況

### API/介面設計：

- 函數簽名或 API 接口定義
- 資料結構和類型定義
- 與其他模組的互動方式

### 驗收標準：

- 功能正確性的驗證方法
- 效能要求和品質標準
- 使用者體驗的期望標準
```

**行為場景提取** (新增):

**目標**: 從需求中識別使用者行為場景,為 Phase 2 測試設計奠定基礎。

**執行步驟**:
1. 閱讀功能需求描述
2. 識別使用者角色和操作
3. 使用 Given-When-Then 格式列出場景
4. 涵蓋正常流程、異常流程、邊界條件

**場景提取範例**:
```markdown
場景 1: [業務流程] - 成功（正常流程）
  Given: [前置條件]
  When: [使用者操作]
  Then: [預期結果]

場景 2: [業務流程] - 失敗（異常流程）
  Given: [異常條件]
  When: [使用者操作]
  Then: [錯誤處理]

場景 3: [業務流程] - 邊界條件
  Given: [極端情況]
  When: [使用者操作]
  Then: [預期行為]
```

**驗證標準**:
- [ ] 每個場景代表獨立可驗證的行為
- [ ] 涵蓋正常流程、異常流程、邊界條件
- [ ] 使用業務語言而非技術術語

**詳細規範請參考**: [BDD測試方法論 - 階段1功能設計]($CLAUDE_PROJECT_DIR/.claude/methodologies/bdd-testing-methodology.md#42-階段-1功能設計---提取行為場景)

**交接給測試工程師**:

- [ ] 功能需求清楚且具體
- [ ] API 介面定義完整
- [ ] 邊界條件和異常情況已識別
- [ ] 驗收標準明確可驗證
- [ ] 行為場景已提取（Given-When-Then 格式）

### 🔍 Phase 1 專家審查：Linux設計品質檢查

**觸發時機**: 功能設計師完成設計規劃後，測試工程師開始前
**負責專家**: linux (Linus Torvalds 程式碼品質專家)

**Linux專家審查重點**:

- **實際問題驗證**: "Is this a real problem or imaginary?" - 拒絕過度設計
- **簡化機會識別**: "Is there a simpler way?" - 尋找最簡解決方案
- **複雜度評估**: 設計是否超過必要複雜度，能否消除特殊情況
- **Good Taste評分**: 設計是否展現技術直覺和經驗積累

**Linux審查輸出標準**:

```markdown
## Linux專家設計審查 (Phase 1)

**Taste Score**: Good taste / Acceptable / Garbage

**核心判斷**: Worth doing [reason] / Not worth doing [reason]

**關鍵洞察**:

- 資料結構: [最關鍵的資料關係]
- 複雜度: [可以消除的複雜度]
- 風險點: [最大的破壞性風險]

**改善建議**:

- [具體的設計簡化建議]
- [特殊情況消除方法]
- [資料結構優化方向]
```

**審查通過標準**:

- [ ] 設計解決實際存在的問題
- [ ] 複雜度合理且必要
- [ ] 沒有可消除的特殊情況
- [ ] 符合"Good Taste"原則

### 🧠 Phase 1 知識捕獲：Memory Network Builder

**觸發條件**: Linux專家審查評定為"Good Taste"或發現重要設計洞察時
**負責Agent**: memory-network-builder

**自動觸發場景**:

- Linux專家評定為"Good Taste"的設計模式
- 發現可消除特殊情況的資料結構設計
- 重要的架構決策和設計原則
- 複雜度簡化的具體方法

**Memory捕獲範例**:

```markdown
Memory類型: decision
標題範例: "使用事件驅動架構消除模組間直接依賴"
觸發原因: Linux專家識別出消除特殊情況的優秀設計
連結: 基於 [[SOLID原則]] → 導致 [[模組解耦策略]]
```

**知識捕獲標準**:

- [ ] 捕獲具體的設計決策和原理
- [ ] 建立與相關概念的連結
- [ ] 記錄決策的前因後果
- [ ] 使用結論導向的標題格式

### 🧪 Phase 2: 測試工程師 - 測試案例設計與實作

**負責角色**: 測試工程師
**目標**: 根據功能設計,設計並實作完整的測試案例

**測試策略決策** (新增):

**目標**: 根據程式碼層級選擇合適的測試策略。

**分層測試決策樹**:
- Layer 3 (UseCase) → **必須使用 BDD 測試**（Given-When-Then）
- Layer 5 (Domain, 複雜邏輯) → 單元測試
- Layer 2 (Behavior, 複雜轉換) → 單元測試
- Layer 1 (UI, 關鍵流程) → 整合測試

**Sociable Unit Tests 原則** ⭐:

**核心原則**: 測試行為而非實作,重構時測試保持穩定。

> **"Tests should be coupled to the behavior of the code and decoupled from the structure of code."**
> — Kent Beck, Test Driven Development By Example

**關鍵策略**:
- **Unit** = Module (1個或多個類別)
- **Isolation** = 只隔離外部世界 (Database, File System, External Services)
- **Mock 策略** = 只 Mock 外部依賴,使用真實 Domain Entities
- **測試目標** = Module API (行為),不測試內部結構

**判斷標準**:

| 依賴類型 | Mock 策略 | 理由 |
|---------|----------|-----|
| Repository (Interface) | ✅ Mock | 外部依賴,測試不關心實作 |
| Service (Interface) | ✅ Mock | 外部依賴,隔離外部系統 |
| Event Publisher (Interface) | ✅ Mock | 外部依賴,驗證事件發布 |
| Domain Entity | ❌ 不 Mock | 內層邏輯,直接使用真實物件 |
| Value Object | ❌ 不 Mock | 內層邏輯,直接使用真實物件 |

**重構安全性驗證** (Phase 4 會再次檢查):

如果重構時測試需要修改,表示測試耦合到實作結構而非行為。

**詳細規範請參考**:
- [行為優先TDD方法論]($CLAUDE_PROJECT_DIR/.claude/methodologies/behavior-first-tdd-methodology.md) - Sociable vs Solitary 詳細對比
- [混合測試策略方法論]($CLAUDE_PROJECT_DIR/.claude/methodologies/hybrid-testing-strategy-methodology.md) - 分層決策樹

**在原工作日誌中新增測試設計章節**:

```markdown
## 測試案例設計

### 測試策略規劃：

基於功能設計師的需求分析，設計以下測試策略：

- 單元測試：測試核心邏輯和邊界條件
- 整合測試：測試與其他模組的互動
- 端對端測試：測試完整的使用者流程

### 具體測試案例：

#### 正常流程測試：

- [測試案例1]: Given [前置條件], When [執行動作], Then [預期結果]
- [測試案例2]: Given [前置條件], When [執行動作], Then [預期結果]

#### 邊界條件測試：

- [邊界測試1]: Given [邊界情況], When [執行動作], Then [預期結果]
- [邊界測試2]: Given [極端輸入], When [執行動作], Then [預期結果]

#### 異常情況測試：

- [異常測試1]: Given [錯誤條件], When [執行動作], Then [預期錯誤處理]
- [異常測試2]: Given [無效輸入], When [執行動作], Then [預期錯誤回應]

### 測試環境設置：

- Mock 物件設計：[列出需要的 Mock]
- 測試資料準備：[列出測試所需資料]
- 測試清理策略：[說明測試後的清理方法]

### 測試實作記錄：

- 實作的測試檔案：[列出建立的測試檔案]
- 測試覆蓋的功能點：[記錄測試涵蓋範圍]
- 發現的設計問題：[記錄在設計測試過程中發現的問題]
```

**實際執行工作**:

1. **撰寫失敗的測試**: 根據設計實作具體的測試程式碼
2. **驗證測試失敗**: 確保測試在沒有實作時會失敗
3. **測試品質檢查**: 確保測試程式碼品質和覆蓋率

**交接給實作工程師**:

- [ ] 所有測試案例已實作為程式碼
- [ ] 測試在沒有功能實作時會失敗（紅燈狀態）
- [ ] 測試覆蓋率達到設計要求
- [ ] 測試程式碼品質良好且可維護

### 🔍 Phase 2 專家審查：雙專家測試品質檢查

**觸發時機**: 測試工程師完成測試案例實作後，實作規劃師開始前
**負責專家**: linux + john-carmack (雙專家聯合審查)

**Linux專家測試審查重點**:

- **測試複雜度評估**: 測試是否過度複雜，能否簡化
- **邊界條件充分性**: 是否測試了所有實際可能的邊界情況
- **真實問題覆蓋**: 測試是否針對實際存在的問題，避免理論測試

**John Carmack效能測試審查重點**:

- **熱路徑測試覆蓋**: 效能關鍵路徑是否有充分測試
- **確定性行為驗證**: 測試是否驗證可預測的行為模式
- **最壞情況測試**: 是否包含最壞情況和極端負載的測試場景
- **狀態管理測試**: 副作用最小化和純函數測試覆蓋

**雙專家審查輸出標準**:

```markdown
## 雙專家測試審查 (Phase 2)

### Linux測試品質審查

**Taste Score**: Good taste / Acceptable / Garbage
**致命問題**: [如有，直接指出最差的部分]
**改善方向**:

- [消除這個特殊情況]
- [這些10行可以變成3行]

### John Carmack效能測試審查

**熱路徑覆蓋**: Comprehensive / Adequate / Insufficient
**確定性驗證**: Strong / Moderate / Weak
**關鍵發現**:

- [效能關鍵路徑識別]
- [狀態管理模式評估]
- [最壞情況處理]

### 聯合建議

- [測試架構改善建議]
- [效能測試加強方向]
- [測試複雜度簡化方法]
```

**雙專家審查通過標準**:

- [ ] Linux: 測試複雜度合理，覆蓋實際問題
- [ ] John Carmack: 效能關鍵路徑測試充分
- [ ] 確定性行為驗證完整
- [ ] 最壞情況測試涵蓋適當

### 🧠 Phase 2 知識捕獲：Memory Network Builder

**觸發條件**: 雙專家審查發現有效測試策略或測試設計洞察時
**負責Agent**: memory-network-builder

**自動觸發場景**:

- 發現特別有效的邊界條件測試策略
- John Carmack識別的效能測試關鍵點
- Linux認可的測試複雜度控制方法
- 確定性行為驗證的創新方法

**Memory捕獲範例**:

```markdown
Memory類型: learning  
標題範例: "邊界條件測試比正常流程測試更容易暴露設計缺陷"
觸發原因: Linux專家發現測試策略的重要洞察
連結: 基於 [[邊界條件分析]] → 導致 [[測試驅動設計改善]]
```

**雙專家協作捕獲**:

```markdown
Memory類型: concept
標題範例: "熱路徑測試需要最壞情況和平均情況雙重覆蓋"  
觸發原因: John Carmack + Linux 專家聯合發現
連結: 基於 [[確定性系統設計]] → 導致 [[效能測試策略]]
```

**知識捕獲標準**:

- [ ] 記錄有效的測試方法和策略
- [ ] 捕獲專家認可的測試模式
- [ ] 建立測試策略間的知識連結
- [ ] 記錄測試複雜度控制的原則

### 💻 Phase 3: 實作執行（兩階段模式）

**核心理念**: Phase 3 採用「語言無關策略規劃 + 語言特定程式碼實作」的兩階段執行模式

**兩階段流程**:

```text
Phase 2 測試設計完成
    ↓
Phase 3a: pepper-test-implementer（語言無關策略規劃）
    ↓
    交接：實作策略、虛擬碼、流程圖
    ↓
Phase 3b: 語言特定代理人（程式碼實作）
    ├─ Flutter → parsley-flutter-developer
    ├─ React → react-developer（未來）
    ├─ Python → python-developer（未來）
    └─ Vue → vue-developer（未來）
    ↓
Phase 4 重構優化
```

### 🎨 Phase 3a: pepper-test-implementer - 語言無關策略規劃

**負責角色**: pepper-test-implementer（TDD 實作規劃師）
**目標**: 設計語言無關的實作策略，為 Phase 3b 提供完整的開發指引

**🚨 重要：Phase 3a 採用簡化版格式（預設）**

**產出規模限制**：
- ✅ **簡化版（預設）**: 200-300 行
  - 目標：核心流程 + 關鍵決策，不包含詳細虛擬碼
  - 適用：大部分測試案例（90%）
- ⚠️ **完整版（例外）**: 300-500 行
  - 觸發條件：複雜演算法、金融計算、效能關鍵路徑
  - 必須分 Ticket 執行
- ❌ **禁止**: 超過 500 行
  - 會超過 pepper 輸出限制（8192 tokens ≈ 800 行）

**核心職責**:

1. **實作策略設計**：規劃語言無關的實作方法和架構決策
2. **簡化版格式優先**：預設使用簡化版（200-300 行），避免輸出超限
3. **流程圖繪製**：建立關鍵流程圖（非所有細節）
4. **架構決策記錄**：記錄重要設計模式選擇
5. **權宜方案識別**：標記可能的技術債務

**在原工作日誌中新增 Phase 3a 實作策略章節**:

**📋 簡化版格式（預設）**:

```markdown
## Phase 3a: 語言無關實作策略（簡化版）

**執行代理人**: pepper-test-implementer
**執行時間**: YYYY-MM-DD
**格式說明**: 採用簡化版格式（200-300 行），提供核心流程和關鍵決策點

### 3a.1 測試檔案名稱

**測試結構**：
- setUp: [簡述環境建立]
- 測試案例 1: [名稱] → [預期結果]
- 測試案例 2: [名稱] → [預期結果]
- tearDown: [簡述清理動作]

**關鍵邏輯**：
- [重要邏輯要點 1]
- [重要邏輯要點 2]
- [Mock 策略]

**驗證點**：
- [主要斷言 1]
- [主要斷言 2]

### 3a.2 測試輔助工具策略

**ToolName**：
- 核心方法：methodName() → 功能說明
- 支援：特殊功能說明
```

**📋 完整版格式（例外情況）**:

僅用於以下場景：
1. 複雜演算法（排序、搜尋、圖論）
2. 金融計算（精度要求高）
3. 效能關鍵路徑（需要詳細優化策略）

```markdown
## Phase 3a: 實作策略規劃（完整版）

### 實作策略設計

**核心演算法**:
- [虛擬碼描述關鍵演算法]
- [資料結構選擇]
- [流程控制邏輯]

**架構決策**:
- [設計模式選擇]
- [模組責任劃分]
- [依賴關係設計]

### 資料流程圖

[Mermaid 流程圖]

### 控制流程圖

[Mermaid 流程圖]

### 關鍵實作指引

**第一階段實作目標**:
- [目標測試群組]
- [實作優先順序]
- [關鍵技術挑戰]

**第二階段實作目標**:
- [後續測試群組]
- [整合策略]
- [優化機會]

### 權宜方案與技術債務

- **最小可用實作**: [讓測試通過的最簡單方案]
- **已知限制記錄**: [當前策略的限制和約束條件]
- **重構準備**: [為 Phase 4 提供的改善建議]

### Ticket 拆分評估（新增）

**評估是否需要拆分 Ticket**：

當實作策略規劃發現以下情況時，建議拆分為 Ticket：
- 預估實作時間 > 30 分鐘
- 預估程式碼行數 > 100 行
- 預估影響檔案 > 5 個
- 預估測試案例 > 10 個

**Ticket 拆分參考**：
- 參考：[Ticket 設計派工方法論]($CLAUDE_PROJECT_DIR/.claude/methodologies/ticket-design-dispatch-methodology.md)
- 量化標準：Simple (5-10min), Medium (10-20min), Complex (20-30min)
- 基於 Clean Architecture 拆分：Interface 定義、具體實作、測試驗證、整合連接

**拆分後的處理**：
- PM 代理人 (rosemary) 建立 Ticket 索引於主版本工作日誌
- 每個 Ticket 獨立執行 Phase 3b 實作
- 每個 Ticket 完成後立即 Review（cinnamon-refactor-owl）

### 語言特定實作注意事項

- [Flutter/Dart 特殊考量]
- [效能最佳化建議]
- [平台特定限制]
```

**Phase 3a 完成標準** (交接給 Phase 3b):

- [ ] 實作策略完整且語言無關
- [ ] 關鍵演算法已用虛擬碼描述
- [ ] 資料流程和控制流程清楚
- [ ] 架構決策有明確理由
- [ ] 技術挑戰已識別並提供解決方向
- [ ] 權宜方案和技術債務已標記

### 💻 Phase 3b: 任務/語言特定代理人 - 程式碼實作

**🚨 重要原則：任務類型優先於專案類型**

**負責角色**: 根據**任務類型**判斷，而非專案類型

**Phase 3b 代理人分派決策樹**：
```text
1. 首先判斷任務類型：
   ├─ Hook 開發 → basil-hook-architect ✅
   ├─ 文件整合 → thyme-documentation-integrator ✅
   ├─ 程式碼格式化 → mint-format-specialist ✅
   ├─ 應用程式開發 → 進入步驟 2
   └─ 其他專業任務 → 對應專業代理人

2. 如果任務類型是「應用程式開發」，才判斷專案類型：
   ├─ Flutter 應用程式 → parsley-flutter-developer
   ├─ React 應用程式 → react-developer（未來）
   ├─ Python 應用程式 → python-developer（未來）
   └─ Vue 應用程式 → vue-developer（未來）
```

**常見錯誤與正確分派**：

| 任務描述 | ❌ 錯誤分派 | ✅ 正確分派 |
|---------|-----------|-----------|
| **開發 Hook 腳本** | parsley-flutter-developer | **basil-hook-architect** |
| **整合工作日誌到方法論** | parsley-flutter-developer | **thyme-documentation-integrator** |
| **格式化 Dart 程式碼** | 主線程 | **mint-format-specialist** |
| **開發 Flutter Widget** | basil-hook-architect | **parsley-flutter-developer** |

**⚠️ 警告**：Startup Hook 的自動分派僅基於專案類型，無法判斷任務類型。主線程必須根據任務性質手動判斷代理人。

**目標**: 將 Phase 3a 的語言無關策略轉換為可執行的程式碼

**核心職責**:

1. **接收 Phase 3a 產出**: 理解虛擬碼、流程圖、架構決策
2. **轉換為程式碼**: 將策略轉換為符合語言規範的實際程式碼
3. **遵循語言規範**: 按照語言特定配置檔案（FLUTTER.md/REACT.md/etc.）的規範
4. **執行測試驗證**: 確保所有測試 100% 通過
5. **處理語言特定問題**: 解決 Widget 生命週期、State 管理、平台特性等
6. **記錄實作差異**: 記錄實際實作與策略的差異和調整

**在原工作日誌中新增 Phase 3b 實作記錄章節**:

```markdown
## Phase 3b: 程式碼實作（語言特定）

### Ticket 執行流程（新增）

**判斷是否拆分 Ticket**：
- 如果 Phase 3a 評估建議拆分 Ticket，PM 代理人建立 Ticket 索引
- 每個 Ticket 獨立執行 Phase 3b 實作並記錄日誌

**Ticket 執行記錄格式**：

若採用 Ticket 模式，在主版本日誌建立 Ticket 索引，並為每個 Ticket 建立獨立日誌：
- 主版本日誌（vX.Y.Z-main.md）：記錄 Ticket 列表和整體進度
- Ticket 日誌（vX.Y.Z-ticket-NNN.md）：記錄單個 Ticket 詳細實作

**Ticket 日誌參考格式**：
- 參考：[Ticket 設計派工方法論]($CLAUDE_PROJECT_DIR/.claude/methodologies/ticket-design-dispatch-methodology.md)
- 包含：Ticket ID、類型、複雜度、SMART 驗收條件、實作記錄

**Ticket Review 時機**：
- 每個 Ticket 完成後立即由 cinnamon-refactor-owl 執行 Review
- Review 通過後才能進行下一個 Ticket

### 實作執行記錄

**實作檔案**:
- [列出建立或修改的程式碼檔案]

**關鍵程式碼片段**:
```[language]
// [展示關鍵實作邏輯]
\```

**與 Phase 3a 策略的差異**:
- [記錄實際實作與策略的調整]
- [說明調整原因]

### 語言特定問題處理

**遇到的挑戰**:
- [記錄語言特定問題]
- [解決方案]

**效能優化**:
- [執行的效能優化]
- [優化效果]

### 測試驗證結果

\```bash
# 測試執行記錄
flutter test  # 或其他測試指令
\```

**測試結果**:
- ✅ X/X tests passed (100%)
- [記錄測試執行時間和覆蓋率]
```

**Phase 3b 完成標準** (交接給 Phase 4):

- [ ] 所有 Phase 2 測試案例 100% 通過
- [ ] 程式碼符合語言特定品質標準
- [ ] 語言特定問題已妥善處理
- [ ] 實作完整記錄，包含與策略的差異
- [ ] 效能符合語言平台要求

### 🔄 Phase 3a → Phase 3b 交接標準

**pepper（Phase 3a）交付給語言特定代理人（Phase 3b）**:

- [ ] **實作策略完整**: 虛擬碼、流程圖、架構決策都已建立
- [ ] **關鍵邏輯明確**: 演算法和資料結構選擇有清楚理由
- [ ] **技術挑戰識別**: 預期的技術難點和解決方向已說明
- [ ] **測試通過路徑**: 如何讓測試通過的策略已規劃
- [ ] **語言注意事項**: 針對目標語言的特殊考量已列出

**語言特定代理人（Phase 3b）完成交接接收**:

- [ ] **理解策略**: 已讀取並理解 Phase 3a 的虛擬碼和流程圖
- [ ] **確認可行性**: 策略在目標語言中可實作
- [ ] **識別語言限制**: 發現任何語言特定限制並準備調整方案

**升級機制**:

- 如果 Phase 3b 代理人發現策略無法實作或有重大缺陷
- 向主線程請求任務重新分派，回到 Phase 3a 重新規劃

### 🔍 Phase 3a 專家審查：John Carmack 策略效能檢查

**觸發時機**: pepper 完成實作策略後，Phase 3b 開始前
**負責專家**: john-carmack (John Carmack 效能系統架構師)

**John Carmack 策略審查重點**:

- **熱路徑識別**: 關鍵執行路徑是否清楚識別
- **演算法複雜度**: 時間和空間複雜度是否合理
- **控制流程設計**: 條件分支是否過深，能否簡化
- **狀態管理策略**: 副作用是否最小化
- **架構邊界合理性**: 抽象層次是否適當

**Phase 3a 審查輸出標準**:

```markdown
## John Carmack 策略效能審查 (Phase 3a)

**策略評估**: Clear / Acceptable / Needs Revision
**演算法複雜度**: Optimal / Acceptable / Suboptimal
**控制流程**: Flat / Acceptable / Too Deep

**關鍵發現**:
- 熱路徑識別: [主要執行路徑分析]
- 演算法選擇: [複雜度評估]
- 控制流程: [簡化機會]
- 狀態管理: [副作用評估]

**策略改善建議**:
- [演算法優化方向]
- [控制流程簡化]
- [狀態管理改善]
```

**Phase 3a 審查通過標準**:

- [ ] 熱路徑清楚識別
- [ ] 演算法複雜度合理
- [ ] 控制流程扁平化
- [ ] 狀態管理符合函數式原則

### 🔍 Phase 3b 專家審查：John Carmack 實作效能檢查

**觸發時機**: 語言特定代理人實作完成後，Phase 4 開始前
**負責專家**: john-carmack (John Carmack 效能系統架構師)

**John Carmack 實作審查重點**:

- **熱路徑執行效能**: 實際執行效能是否符合預期
- **最壞情況優化**: 設計是否針對最壞情況效能
- **語言特定最佳化**: 是否善用語言平台特性
- **記憶體管理**: 記憶體使用是否合理
- **確定性行為**: 行為是否可預測和一致

**Phase 3b 審查輸出標準**:

```markdown
## John Carmack 實作效能審查 (Phase 3b)

**效能評估**: Excellent / Acceptable / Needs Improvement
**確定性設計**: Strong / Moderate / Weak
**語言最佳化**: Well-utilized / Adequate / Missed Opportunities

**關鍵發現**:
- 熱路徑效能: [實際執行效能分析]
- 語言特性: [語言平台特性利用情況]
- 記憶體管理: [記憶體使用評估]
- 確定性行為: [行為一致性評估]

**效能優化建議**:
- [具體的效能優化方向]
- [語言特性利用機會]
- [記憶體優化策略]

**架構風險點**:
- [效能瓶頸識別]
- [確定性行為風險]
- [語言特定限制]
```

**Phase 3b 審查通過標準**:

- [ ] 熱路徑效能合理
- [ ] 語言平台特性善用
- [ ] 記憶體管理合理
- [ ] 確定性行為充分
- [ ] 沒有明顯的效能瓶頸

### 🧠 Phase 3 知識捕獲：Memory Network Builder

**觸發條件**: John Carmack 專家審查發現重要洞察時
**負責Agent**: memory-network-builder

**Phase 3a 知識捕獲場景**:

- 策略設計的關鍵決策
- 演算法選擇的理由和效果
- 控制流程簡化的具體方法
- 語言無關架構模式

**Phase 3b 知識捕獲場景**:

- 語言特定實作技巧
- 平台特性利用方法
- 效能優化具體數據
- 策略轉換的經驗

**Memory 捕獲範例**:

```markdown
Memory類型: implementation
標題範例: "使用 Map 代替 Array 查找讓搜尋效能提升10倍"
觸發原因: John Carmack 專家發現關鍵效能優化點
連結: 基於 [[熱路徑識別]] → 導致 [[資料結構選擇策略]]
```

**架構模式捕獲**:

```markdown
Memory類型: concept
標題範例: "Phase 3 兩階段模式讓策略可跨語言重用"
觸發原因: 驗證了語言無關策略的可重用性
連結: 基於 [[策略規劃]] → 導致 [[多語言支援]]
```

**知識捕獲標準**:

- [ ] 記錄策略設計的成功模式
- [ ] 捕獲語言特定實作技巧
- [ ] 建立策略與實作的連結
- [ ] 記錄效能優化數據和方法

### 🏗️ Phase 4: 重構設計師 - 程式碼品質改善與需求註解

**負責角色**: 重構設計師
**目標**: 改善程式碼品質和架構，執行完整的重構方法論，並建立需求保護機制

**重要**: 重構設計師必須按照本文件「🧠 TDD 驅動重構方法論」章節的完整流程執行

**🎯 UI 開發自動觸發效能檢查**:

**觸發條件判斷**:
- 如果當前開發任務涉及 UI Widget（檢查 Phase 1-3 工作日誌關鍵字：Widget、UI、畫面、渲染）
- 則 Phase 4 分為兩個子階段執行：
  - **Phase 4-1**: ginger-performance-tuner UI 效能檢查（自動分派）
  - **Phase 4-2**: 重構設計師程式碼品質改善

**Phase 4 執行流程**:

```text
Phase 3 實作完成
    ↓
判斷是否 UI 相關開發？
    ↓
  [是] → Phase 4-1: ginger-performance-tuner 效能檢查
           ↓
         Phase 4-2: 重構設計師品質改善
    ↓
  [否] → Phase 4: 重構設計師品質改善
```

### 🚀 Phase 4-1: ginger-performance-tuner UI 效能檢查 (UI 開發專用)

**負責角色**: ginger-performance-tuner (效能優化規劃專家)
**目標**: 從設計面識別和預防效能問題，確保 UI 不阻塞使用者操作

**效能檢查項目**:

#### 1. **渲染效能檢查**
```dart
// 檢查點: 避免一次性渲染過多內容
❌ 錯誤: Column(children: List.generate(1000, ...))  // 同時渲染 1000 個 Widget
✅ 正確: ListView.builder(itemCount: 1000, ...)      // 按需渲染
```

**評估標準**:
- 單次渲染 Widget 數量 < 50 個
- 列表/網格必須使用 builder 模式
- 複雜佈局考慮 AutomaticKeepAliveClientMixin

#### 2. **時間複雜度檢查**
```dart
// 檢查點: 避免高時間複雜度的 UI 構建邏輯
❌ 錯誤: O(n²) 巢狀迴圈產生 Widget
✅ 正確: O(n) 線性邏輯 + 資料預處理
```

**評估標準**:
- Widget build 方法內禁止 O(n²) 以上邏輯
- 複雜運算移至 ViewModel 或 UseCase
- 善用 const Widget 和 cached 值

#### 3. **異步處理策略**
```dart
// 檢查點: UI 阻塞風險識別
❌ 錯誤:
  Future<void> build() async {
    final data = await fetchData();  // 阻塞 UI 渲染
  }

✅ 正確:
  // ViewModel 處理異步
  viewModel.loadData();

  // UI 顯示 Loading State
  if (state.isLoading) return LoadingWidget();
```

**評估標準**:
- Widget build 方法必須同步執行
- 異步操作移至 ViewModel/UseCase
- 提供明確的 Loading/Error State

#### 4. **Isolate 使用建議**
```dart
// 檢查點: 資料解析和計算分離
❌ 錯誤:
  List<Book> parseBooks(String json) {
    return jsonDecode(json);  // 主執行緒解析大量 JSON
  }

✅ 正確:
  Future<List<Book>> parseBooks(String json) async {
    return compute(_parseInIsolate, json);  // Isolate 處理
  }
```

**評估標準**:
- JSON 解析 > 1MB → 使用 Isolate
- 大量資料計算 → 使用 compute()
- 圖片處理 → 使用 Isolate

**效能檢查報告格式**:

```markdown
## UI 效能檢查報告 (Phase 4-1)

### 檢查項目結果

#### ✅ 渲染效能
- ListView.builder 使用正確
- 單次渲染 Widget < 30 個

#### ⚠️  異步處理
- 發現 1 處 UI 阻塞風險: `BookListWidget.build` 包含 await
- 建議: 移至 ViewModel，提供 Loading State

#### ✅ 時間複雜度
- 所有 build 方法 O(n) 線性複雜度
- 無巢狀迴圈產生 Widget

#### ⚠️  Isolate 使用
- JSON 解析未使用 Isolate (資料量 < 100KB，可接受)
- 建議: 若資料量增長，考慮使用 compute()

### 優先修復項目
1. [高優先] BookListWidget async build 阻塞問題
2. [中優先] 考慮 JSON 解析 Isolate 策略

### 效能設計確認
- [ ] 無 UI 主執行緒阻塞
- [ ] 異步操作提供 Loading State
- [ ] 大量渲染使用 builder 模式
- [ ] 資料處理考慮 Isolate 分離
```

**交接給重構設計師**:
- [ ] 效能檢查報告完成
- [ ] 高優先問題已識別並提供解決方案
- [ ] 設計面效能風險已記錄

### 🏗️ Phase 4-2: 重構設計師品質改善

**工作流程**:

1. **UI 開發判斷與分派** (主線程責任):
   - 檢視 Phase 1-3 工作日誌，判斷是否為 UI 相關開發
   - 如果是 UI 開發，先分派 ginger-performance-tuner 執行效能檢查
   - 效能檢查完成後，再分派重構設計師執行品質改善

2. **建立重構工作日誌**: 按照重構方法論 Phase 1 要求建立新工作日誌
3. **執行重構與註解撰寫**: 按照重構方法論 Phase 2 執行重構並驗證預期
4. **完成重構總結**: 按照重構方法論 Phase 3 完成工作日誌總結

**測試穩定性檢查** (新增):

**目標**: 驗證測試是否耦合到行為而非實作結構。

**核心原則**: 重構時測試應保持穩定,如果測試需要修改表示測試設計錯誤。

**測試耦合目標驗證檢查清單**:

```markdown
重構類型檢查：
- [ ] 重構內部邏輯 → 測試無需修改？
- [ ] 改變演算法實作 → 測試無需修改？
- [ ] 調整類別結構 → 測試無需修改？
- [ ] 替換 Repository 實作 → 測試無需修改？
- [ ] 重新命名私有方法 → 測試無需修改？

判斷標準：
✅ 全部「測試無需修改」→ 測試耦合到行為（正確）
❌ 任何「測試需修改」→ 測試耦合到實作（錯誤）
```

**如果檢查未通過**:

```markdown
測試需要修改 = 測試設計問題
  ↓
升級為 Phase 2 問題
  ↓
重新設計測試（使用 Sociable Unit Tests 原則）
  ↓
確保測試只透過 Module API 與系統互動
```

**驗證範例**:

| 變更類型 | 測試是否需要修改 | 判斷 |
|---------|----------------|-----|
| 重構內部邏輯 | ❌ 否 | ✅ 正確（測試行為） |
| 改變演算法實作 | ❌ 否 | ✅ 正確（測試行為） |
| 替換 Repository 實作 | ❌ 否 | ✅ 正確（測試行為） |
| 改變業務規則 | ✅ 是 | ✅ 正確（行為改變） |
| 調整錯誤訊息 | ✅ 是 | ✅ 正確（可觀察行為改變） |

**詳細規範請參考**: [行為優先TDD方法論 - 第7章測試穩定性驗證]($CLAUDE_PROJECT_DIR/.claude/methodologies/behavior-first-tdd-methodology.md#72-測試穩定性驗證)

**新增要求 - 需求註解撰寫**:

重構設計師必須遵循「[程式碼註解撰寫方法論]($CLAUDE_PROJECT_DIR/.claude/methodologies/comment-writing-methodology.md)」執行以下任務：

- **全面檢視設計文件**: 重新審查所有相關需求規格和設計文件
- **需求註解覆蓋**: 為所有業務邏輯函式新增需求脈絡註解
- **維護指引建立**: 為複雜邏輯建立修改約束和相依性警告
- **語意化命名**: 確保函式和變數命名達到自說明標準

**註解撰寫標準**:

```dart
/// 需求：[UC/BR編號] [簡短描述]
/// [詳細業務描述]
/// 約束：[限制條件和邊界規則]
/// [維護指引：修改須知、相依性警告]
```

**重構總結工作日誌更新**: 按照「📚 專案文件責任明確區分」章節的工作日誌品質要求進行記錄

**最終交付標準**:

- [ ] 重構方法論完整執行
- [ ] 所有技術債務已解決
- [ ] 程式碼品質達到專案標準
- [ ] 功能完整性確認無損
- [ ] **自然語言可讀性達標**: 程式碼如同閱讀自然語言般流暢
- [ ] **五行函式職責達標**: 所有函式控制在5-10行且職責單一
- [ ] **事件驅動架構達標**: if/else 判斷正確分解為事件處理
- [ ] **變數職責專一化達標**: 變數只承載單一類型資料，無縮寫
- [ ] **需求註解覆蓋率 100%**: 所有業務邏輯函式都有需求脈絡註解
- [ ] **設計文件審查完成**: 確認程式碼與最新需求規格一致
- [ ] **語意化命名達標**: 程式碼達到自說明標準
- [ ] 重構經驗記錄完整

### 🚨 Phase 4 完成後的強制提交

**觸發時機**: Phase 4 完成，所有最終交付標準達成

**強制原則**: **小版本完成 = 立即提交做存底**

**為什麼強制提交**:
- ✅ **安全性**: 防止工作成果遺失
- ✅ **可回溯性**: 提供版本回溯點
- ✅ **定期存檔**: 確保工作進度有明確記錄
- ✅ **後續調整空間**: 即使需要調整，也有提交記錄可以參考

**提交前檢查**:
- [ ] 所有測試 100% 通過
- [ ] Linux 最終品質審查通過
- [ ] 工作日誌完整記錄（包含 Phase 1-4）
- [ ] 程式碼品質達標

**🚨 提交狀態確認（強制執行）**:

```bash
# 強制步驟：執行 git log 確認提交狀態
git log --oneline -3

# 確認最新提交是否為當前版本
# 格式：feat(vX.Y.Z): [功能描述] - TDD 四階段完成
```

**提交狀態判斷**:
- ✅ **已提交**: 最新 commit 訊息包含當前版本號 `(vX.Y.Z)`
- ❌ **未提交**: 最新 commit 不是當前版本，需要立即提交

**提交操作**:

```bash
# 1. 加入所有相關檔案
git add [功能實作檔案] [測試檔案] [工作日誌]

# 2. 撰寫完整提交訊息（必須包含 TDD 四階段摘要）
git commit -m "feat(vX.Y.Z): [功能描述] - TDD 四階段完成

## TDD 四階段執行

### Phase 1: 功能設計
[設計摘要]

### Phase 2: 測試驗證
[測試成果摘要]

### Phase 3: 實作執行
[實作完成度摘要]

### Phase 4: 重構優化
[重構成果摘要]

## 測試狀態
✅ X/X tests passed (100%)

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

**禁止行為**:
- ❌ 「等一下再提交」
- ❌ 「先做下一個版本再一起提交」
- ❌ 「改天再整理提交」

**Hook 系統支援**:
- 🎯 Version Completion Hook 會檢測 Phase 4 完成並提醒提交
- 📋 Document Sync Hook 確保工作日誌包含在提交中

### 🔍 Phase 4 專家審查：Linux最終品質檢查

**觸發時機**: 重構設計師完成所有重構工作後，TDD循環完成前
**負責專家**: linux (Linus Torvalds 程式碼品質專家)

**Linux最終品質審查重點**:

- **重構效果驗證**: 重構是否真正簡化了程式碼，而非增加複雜度
- **Good Taste最終評估**: 最終程式碼是否展現"好品味"和技術直覺
- **複雜度消除確認**: 是否成功消除了不必要的複雜度和特殊情況
- **破壞性檢查**: "Never break userspace" - 確保向後相容性
- **實用主義驗證**: 程式碼是否服務於現實需求，而非理論完美

**Linux最終審查輸出標準**:

```markdown
## Linux最終品質審查 (Phase 4)

**最終Taste Score**: Good taste / Acceptable / Garbage

**重構成效評估**:

- 複雜度變化: [重構前後複雜度對比]
- 特殊情況: [消除的特殊情況數量]
- 程式碼行數: [有意義的程式碼精簡]

**Good Taste評估**:

- 資料結構設計: [是否展現對資料結構的深度理解]
- 算法選擇: [是否選擇了最直觀的解決方法]
- 邊界處理: [特殊情況是否被優雅消除]

**向後相容性檢查**:

- [ ] 沒有破壞現有API
- [ ] 沒有改變外部行為
- [ ] 升級路徑清晰

**最終建議**:

- [如果是Good taste: 讚揚具體的優秀設計]
- [如果是Acceptable: 指出還可改善的地方]
- [如果是Garbage: 要求重新設計的具體理由]
```

**Linux最終審查通過標準**:

- [ ] 程式碼展現"Good Taste"或至少"Acceptable"
- [ ] 複雜度確實降低，沒有增加不必要複雜性
- [ ] 向後相容性完全保持
- [ ] 解決方案務實且直接
- [ ] 沒有為了理論完美而犧牲實用性

### 🧠 Phase 4 知識捕獲：Memory Network Builder

**觸發條件**: Linux最終審查發現"Good Taste"重構模式或重要品質改善時
**負責Agent**: memory-network-builder

**自動觸發場景**:

- Linux專家認證的"Good Taste"重構模式
- 成功消除特殊情況的具體重構方法
- 複雜度大幅降低的重構案例
- 向後相容性維持的重構技巧
- 實用主義導向的架構改善

**重構模式捕獲**:

```markdown
Memory類型: concept
標題範例: "消除if-else特殊情況的三種資料結構重設計模式"
觸發原因: Linux專家認證的"Good Taste"重構方法
連結: 基於 [[特殊情況識別]] → 導致 [[資料結構優化]]
```

**品質改善捕獲**:

```markdown
Memory類型: learning
標題範例: "重構後程式碼行數減少60%且可讀性提升的關鍵因素"
觸發原因: Linux專家驗證的重構成效
連結: 基於 [[複雜度分析]] → 導致 [[程式碼品質提升]]
```

**架構債務解決捕獲**:

```markdown
Memory類型: implementation
標題範例: "模組循環依賴透過事件中介者模式徹底解除"
觸發原因: 重構過程解決關鍵架構債務
連結: 基於 [[依賴解耦]] → 導致 [[模組化架構]]
```

**知識捕獲標準**:

- [ ] 記錄成功的重構模式和方法
- [ ] 捕獲複雜度簡化的具體技巧
- [ ] 建立重構前後的效果對比數據
- [ ] 記錄向後相容性維持的策略
- [ ] 捕獲"Good Taste"的具體體現方式

## 🤝 TDD 協作流程總結

### 🎫 Ticket 機制在協作流程中的角色（新增）

**Ticket 機制整合重點**：

**Phase 3a 的 Ticket 拆分評估**：
- pepper-test-implementer 評估實作複雜度
- 根據量化標準（時間、程式碼行數、影響檔案、測試案例）判斷是否需要拆分
- 建議拆分時提供 Ticket 拆分方案

**PM 代理人 (rosemary) 的 Ticket 職責**：
- 基於 Phase 3a 評估建立 Ticket 索引
- 在主版本工作日誌（vX.Y.Z-main.md）記錄 Ticket 列表
- 協調 Ticket 執行順序和依賴關係
- 監控 Ticket 執行狀態（Pending → In Progress → Review → Completed）

**執行代理人的 Ticket 執行**：
- 每個 Ticket 獨立執行 Phase 3b 實作
- 建立獨立 Ticket 日誌（vX.Y.Z-ticket-NNN.md）
- 遵循 SMART 驗收條件
- 完成後立即觸發 Review

**cinnamon-refactor-owl 的 Ticket Review**：
- 每個 Ticket 完成後立即執行 Review
- 檢查程式碼品質、測試通過率、Clean Architecture 合規性
- Review 通過後該 Ticket 標記為 Completed
- Review 未通過時要求修正並重新提交

**Ticket 機制效益**：
- ✅ **任務可管理性**：大任務拆分為 5-30 分鐘可完成單元
- ✅ **進度可追蹤**：每個 Ticket 狀態明確，整體進度清晰
- ✅ **品質可控制**：每個 Ticket 獨立 Review，問題及早發現
- ✅ **協作可協調**：PM 代理人統籌全局，執行代理人專注實作

### 📋 完整協作檢查清單

**階段完成驗證**:

- [ ] Phase 1: 功能設計師完成需求分析和功能規劃
  - [ ] Linux專家設計品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (設計決策和原則)
- [ ] Phase 2: 測試工程師完成測試案例設計和實作
  - [ ] Linux + John Carmack雙專家測試品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (測試策略和洞察)
- [ ] Phase 3: 實作工程師完成功能實作和測試通過
  - [ ] **🎫 Ticket 拆分評估完成** (Phase 3a)
  - [ ] **🎫 所有 Ticket 執行並 Review 通過** (Phase 3b)
  - [ ] John Carmack架構效能審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (實作技巧和效能優化)
- [ ] Phase 4: 重構設計師完成程式碼品質改善
  - [ ] Linux最終品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (重構模式和品質改善)
- [ ] **🚨 小版本完成即提交**: Phase 4 完成後立即執行 git commit

**工作日誌品質**: 必須符合「[📚 專案文件責任明確區分](./document-responsibilities.md)」章節的文件品質標準

**最終交付標準**:

- [ ] 所有測試 100% 通過
- [ ] 程式碼品質達到專案標準
- [ ] 功能完全符合原始設計規格
- [ ] 沒有未解決的技術債務
- [ ] 完整的開發過程可追蹤
- [ ] **所有專家審查通過** (Linux設計審查 + 雙專家測試審查 + John Carmack架構審查 + Linux最終審查)
- [ ] **專家審查建議全部實施** 或有明確原因記錄為何不實施
- [ ] **🧠 知識網路完整建立**: 所有重要洞察已捕獲為Memory並建立適當連結
- [ ] **Memory品質驗證**: 所有Memory標題結論導向，內容原子化，連結關係明確

### 🔍 TODO 狀態驗證機制 (v0.9.24 新增預防措施)

**背景**: 為防止專案文件與實際狀況不一致的問題 (如 v0.9.24 發現的 Popup 狀態不一致問題)，建立強制性的狀態驗證機制。

**🚨 每個 TDD 循環完成後的必要檢查**:

**文件更新檢查**: 按照「[📚 專案文件責任明確區分](./document-responsibilities.md)」章節的要求執行：

- [ ] **工作日誌更新**: 符合工作日誌品質標準
- [ ] **TODO.md狀態同步**: 符合TODO.md品質標準
- [ ] **CHANGELOG.md更新**: 符合CHANGELOG.md品質標準

**實際狀況交叉驗證**:

- [ ] **測試檔案確認**: 聲稱完成的功能必須有對應的測試檔案
- [ ] **程式碼實作確認**: 檢查實際程式碼是否支持 TODO 中的功能聲明
- [ ] **版本號一致性**: 確保各檔案中的版本號保持一致
- [ ] **架構文件同步**: 更新相關的架構文件和說明

**版本發布前的全面驗證**:

- [ ] **批次狀態檢查**: 檢查所有聲稱完成的項目是否有實際實作
- [ ] **測試覆蓋驗證**: 確認測試覆蓋率聲明與實際測試結果一致
- [ ] **工作日誌完整性**: 驗證重要功能都有對應的開發記錄
- [ ] **CHANGELOG 同步**: 確保版本變更記錄反映真實的功能變更

**🛠️ 推薦的驗證工具**:

```bash
# 建議建立的驗證腳本概念
verify_project_consistency() {
  echo "🔍 檢查 TODO 狀態一致性..."
  # 檢查 TODO 中聲稱完成的功能是否有對應測試檔案
  # 檢查版本號在 TODO.md, CHANGELOG.md, package.json 中是否一致
  # 驗證工作日誌的完整性
}
```

**📋 問題發現時的標準處理流程**:

1. **立即停止當前工作**: 優先處理狀態不一致問題
2. **系統性調查**: 使用程式碼分析、測試檢查、歷史記錄搜尋等方法
3. **實際狀況導向修正**: 基於具體實作情況進行文件修正
4. **建立預防機制**: 設計防止類似問題再次發生的具體措施
5. **完整記錄過程**: 建立工作日誌記錄發現和修正的完整過程

---

## 🧠 TDD 驅動重構方法論：預期管理與工作日誌為核心

### 🎯 重構核心原則：預期管理與驗證

**重構是預期管理與驗證的思考框架，不是執行步驟**：

- **預期管理**: 重構前先預期哪些測試會通過、哪些會失敗、為什麼失敗
- **驗證預期**: 執行重構後檢查結果是否符合預期
- **預期偏差處理**: 若結果不符合預期，分析原因並調整計劃
- **工作日誌記錄**: 記錄整個思考和驗證過程，確保知識傳承和協作透明

### 📝 Phase 1: 重構計劃與工作日誌建立

**必須建立新工作日誌的原因**: 確保重構思考過程可追蹤、協作透明、知識不流失

**工作日誌必須回答的問題**:

1. **🎯 重構動機與目標**:

   ```markdown
   ## 為什麼要重構？

   - 當前架構的具體問題是什麼？
   - 重構後期望達成的狀態是什麼？
   - 這個重構如何解決核心問題？
   ```

2. **🔍 影響範圍分析**:

   ```markdown
   ## 預期影響的程式碼和行為

   - 哪些檔案會被修改？
   - 哪些功能的行為會改變？
   - 哪些 API 或介面會受影響？
   ```

3. **🧪 測試預期管理**:

   ```markdown
   ## 測試結果預期

   ### 預期會通過的測試：

   - [列出具體測試檔案和測試名稱]
   - 為什麼這些測試應該繼續通過？

   ### 預期會失敗的測試：

   - [列出具體測試檔案和測試名稱]
   - 為什麼這些測試會失敗？失敗的原因是什麼？
   - 怎麼修正這些失敗？

   ### 不確定的測試：

   - [可能會受影響的測試]
   - 為什麼不確定？需要特別注意什麼？
   ```

4. **📊 成功標準設定**:

   ```markdown
   ## 重構成功的標準

   - 測試結果符合預期的標準是什麼？
   - 程式碼品質的要求是什麼？
   - 效能或使用者體驗的標準是什麼？
   ```

### 🚀 Phase 2: 重構執行與預期驗證

**執行目的**: 驗證重構計劃中的預期是否正確，不是單純的執行步驟

**Step 1: 執行重構**

```bash
# 按照計劃執行重構
# [這裡是具體的重構動作]
```

**Step 2: 驗證測試結果**

```bash
npm test                # 執行所有測試
npm run test:unit       # 單元測試
npm run test:integration # 整合測試
```

**Step 3: 對比預期與實際結果**

**情境 A: 結果符合預期 ✅**

- 預期通過的測試都通過了
- 預期失敗的測試都失敗了，且失敗原因符合預期
- 不確定的測試結果都在可接受範圍內

**對應行動**: 更新工作日誌

```markdown
## 重構結果驗證 - 符合預期 ✅

### 測試結果記錄：

- [具體記錄測試結果]

### 重構過程發現：

- [記錄重構過程中的發現和決策]

### 下一步：

- 重構目標已達成，繼續後續優化
```

**情境 B: 結果不符合預期 ❌**

- 預期通過的測試失敗了
- 預期失敗的測試通過了，或失敗原因與預期不符
- 出現了預期之外的測試失敗

**對應行動**: 更新工作日誌，分析偏差

```markdown
## 重構結果驗證 - 不符合預期 ❌

### 預期偏差分析：

- [具體記錄哪些預期出現偏差]
- [分析為什麼會有偏差]
- [記錄意外發現的問題]

### 下一步行動決策：

- ☀️ 選擇1: 修正當前問題，繼續原計劃
- 🔄 選擇2: 調整重構計劃，縮小範圍
- 🏠 選擇3: 回到穩定狀態，重新設計
```

### 📝 Phase 3: 重構完成與工作日誌總結

**完成驗證目的**: 確保重構達成目標，並記錄學習成果供未來參考

**最終驗證檢查**:

```bash
# 基本功能驗證
npm test                # 所有測試必須通過
npm run test:unit       # 單元測試必須通過
npm run test:integration # 整合測試必須通過

# 品質與效能驗證
npm run lint            # Linter 檢查必須通過
npm run build           # 建置必須成功
npm run test:coverage   # 測試覆蓋率檢查
```

**工作日誌總結更新**:

```markdown
## 重構總結與學習

### 目標達成情況：

- [ ] 原定目標是否達成？
- [ ] 架構問題是否得到解決？
- [ ] 程式碼品質是否符合預期？

### 預期管理的學習：

- 哪些預期是正確的？為什麼？
- 哪些預期是錯誤的？為什麼？
- 下次類似重構應該注意什麼？

### 方法論的改進：

- 重構計劃的哪些部分需要改進？
- 測試預期的方法可以怎麼優化？
- 未來類似問題的預防策略是什麼？
```

### 📋 重構方法論檢查清單

**重構開始前**:

- [ ] 已建立新的工作日誌
- [ ] 明確記錄重構動機和目標
- [ ] 詳細分析影響範圍
- [ ] 建立測試結果預期
- [ ] 設定成功標準

**重構過程中**:

- [ ] 測試結果與預期對比
- [ ] 預期偏差的立即分析
- [ ] 工作日誌的即時更新

**重構完成後**:

- [ ] 目標達成情況的總結
- [ ] 預期管理的學習記錄
- [ ] 方法論改進建議
- [ ] 未來預防策略建立

---

**🔗 相關文件連結**:

- [返回主指導文件](./../../CLAUDE.md)
- [專案文件責任明確區分](./document-responsibilities.md)
- [Agent 協作規範](./agent-collaboration.md)
