# TDD-Ticket 整合方法論

**版本**: v1.0.0
**建立日期**: 2025-12-29
**核心目的**: 統一整合 Ticket 系統與 TDD 四階段流程

---

## 方法論概述

本方法論定義 Ticket 系統與 TDD 四階段流程的整合機制，確保每個功能開發都經過適當的單一職責評估。

**核心問題**：
- Ticket 系統和 TDD 流程原本是獨立的
- 開發者容易跳過 Ticket 設計直接進入實作
- 沒有強制的決策點來評估是否需要拆分

**解決方案**：
- 在 Phase 3a 設立**強制單一職責評估**步驟
- 使用 Atomic Ticket 四大檢查作為唯一決策標準
- 任一檢查未通過時強制執行 Ticket 拆分

---

## 第一章：核心原則

### 1.1 Phase 3a 是唯一決策點

Ticket 設計決策**只在 Phase 3a 進行**：

| TDD 階段 | Ticket 決策 | 說明 |
|---------|------------|------|
| Phase 1 | 不進行 | 專注功能設計 |
| Phase 2 | 不進行 | 專注測試設計 |
| **Phase 3a** | **執行** | **強制單一職責評估** |
| Phase 3b | 不進行 | 按評估結果執行 |
| Phase 4 | 不進行 | 跨 Ticket 重構 |

### 1.2 禁止使用量化指標

**禁止使用的評估指標**：
- 時間估計（30 分鐘、1 小時）
- 測試案例數量（5 個、10 個）
- 程式碼行數（100 行、500 行）
- 檔案數量（3 個、5 個）

**理由**：這些指標不反映職責是否單一，只反映工作量大小。

### 1.3 唯一評估標準：單一職責四大檢查

| 檢查項目 | 問題 | 通過標準 |
|---------|------|---------|
| **語義檢查** | 能用「動詞 + 單一目標」表達嗎？ | 只有一個目標 |
| **修改原因檢查** | 只有一個修改原因嗎？ | 只有一個原因會觸發修改 |
| **驗收一致性** | 所有驗收條件指向同一目標嗎？ | 全部指向同一目標 |
| **依賴獨立性** | 拆分後不會產生循環依賴嗎？ | 無循環依賴 |

**決策邏輯**：
- 四項都通過 → 單一 Ticket（或直接執行）
- 任一項未通過 → 必須拆分為多個 Atomic Tickets

---

## 第二章：決策流程

### 2.1 Phase 3a 單一職責評估流程

```text
Phase 3a 開始
    |
    v
步驟 1: 讀取 Phase 2 測試設計
    |
    v
步驟 2: 定義任務描述
    |
    v
步驟 3: 執行四大檢查
    |
    +-- 語義檢查
    +-- 修改原因檢查
    +-- 驗收一致性檢查
    +-- 依賴獨立性檢查
    |
    v
步驟 4: 輸出評估結論（記錄到工作日誌）
    |
    v
步驟 5: 決策執行
    |
    +-- 全部通過 -> 繼續策略規劃
    |
    +-- 任一未通過 -> 執行 /ticket-create
```

### 2.2 四大檢查執行細節

#### 檢查 1：語義檢查

**執行步驟**：
1. 將任務用「動詞 + 目標」格式描述
2. 確認是否只有一個目標

**符合標準範例**：
```text
實作 startScan() 方法
修復 ISBN 驗證邏輯
新增 BookRepository.save() 測試
```

**違反標準範例**：
```text
實作掃描功能和離線支援  <- 兩個目標
修復 ISBN 驗證和優化效能  <- 兩個行動
```

#### 檢查 2：修改原因檢查

**執行步驟**：
1. 列出可能導致修改此 Ticket 的原因
2. 確認是否只有一個原因

**符合標準範例**：
```text
Ticket: 實作 startScan() 方法
修改原因: 只有「掃描 API 變更」會影響
-> 單一修改原因，通過
```

**違反標準範例**：
```text
Ticket: 實作掃描功能和離線支援
修改原因 1: 掃描 API 變更
修改原因 2: 離線儲存格式變更
-> 多個修改原因，需拆分
```

#### 檢查 3：驗收一致性檢查

**執行步驟**：
1. 列出所有驗收條件
2. 確認是否都指向同一目標

**符合標準範例**：
```yaml
ticket: 實作 startScan() 方法
acceptance:
  - startScan() 方法簽名正確
  - startScan() 回傳值類型正確
  - startScan() 單元測試通過
# 所有驗收條件都是關於 startScan()，通過
```

**違反標準範例**：
```yaml
ticket: 實作掃描功能
acceptance:
  - startScan() 方法通過測試
  - stopScan() 方法通過測試
  - 離線快取功能正常
# 驗收條件指向多個不同目標，需拆分
```

#### 檢查 4：依賴獨立性檢查

**執行步驟**：
1. 如果考慮拆分，分析拆分後的依賴關係
2. 確認是否會產生循環依賴

**可以拆分（無循環依賴）**：
```text
Ticket A: 實作 startScan()
Ticket B: 實作 stopScan()
依賴關係: B 依賴 A（單向）
-> 獨立，應拆分
```

**不應拆分（有循環依賴）**：
```text
Ticket A: 實作掃描啟動邏輯
Ticket B: 實作掃描狀態管理
依賴關係: A 需要 B 的狀態，B 需要 A 的啟動
-> 循環依賴，保持為同一 Ticket
```

### 2.3 Ticket 拆分後的執行流程

```text
/ticket-create（建立所有 Tickets）
    |
    v
PM 審核 Tickets（確認單一職責）
    |
    v
按 Wave 順序執行 Tickets
    |
    v
每個 Ticket:
    |
    +-- /ticket-track claim
    |
    +-- 實作
    |
    +-- /ticket-track complete
    |
    +-- 即時 Review（cinnamon-refactor-owl）
```

### 2.4 評估結論記錄格式

**記錄到工作日誌的格式**：

```markdown
## Phase 3a: 單一職責評估

**任務描述**: [動詞 + 目標]

### 四大檢查結果

| 檢查項目 | 結果 | 說明 |
|---------|------|------|
| 語義檢查 | PASS/FAIL | [說明] |
| 修改原因檢查 | PASS/FAIL | [說明] |
| 驗收一致性檢查 | PASS/FAIL | [說明] |
| 依賴獨立性檢查 | PASS/FAIL | [說明] |

### 評估結論

- [ ] 四項全部通過 -> 繼續策略規劃
- [ ] 任一項未通過 -> 執行 Ticket 拆分

### 拆分方案（如適用）

[列出拆分後的 Ticket 清單和 Wave 規劃]
```

---

## 第三章：與其他方法論的關係

本方法論整合以下文件：

| 文件 | 關係 | 說明 |
|------|------|------|
| [TDD 協作開發流程](../tdd-collaboration-flow.md) | 主流程 | 定義四階段和專家審查 |
| [Atomic Ticket 方法論](./atomic-ticket-methodology.md) | 設計原則 | 單一職責四大檢查 |
| [Frontmatter Ticket 追蹤](./frontmatter-ticket-tracking-methodology.md) | 追蹤機制 | 狀態管理和指令 |
| [Ticket 設計派工](./ticket-design-dispatch-methodology.md) | 派工規範 | 5W1H 設計和驗收 |

### 3.1 與 TDD 協作開發流程的關係

**整合點**：Phase 3a 是 TDD 流程中的**策略規劃階段**，本方法論在此階段插入**強制單一職責評估**。

**執行順序**：
```text
Phase 2 測試設計完成
    |
    v
Phase 3a 開始
    |
    v
[本方法論] 單一職責評估  <- 整合點
    |
    +-- 通過 -> 繼續 Phase 3a 策略規劃
    +-- 未通過 -> 執行 Ticket 拆分 -> 每個 Ticket 獨立執行 Phase 3b
    |
    v
Phase 3b 程式碼實作
```

### 3.2 與 Atomic Ticket 方法論的關係

**本方法論引用 Atomic Ticket 方法論的**：
- 單一職責四大檢查標準
- Ticket ID 命名規範（`{VERSION}-W{WAVE}-{SEQ}`）
- Wave 依賴定義（W1 無依賴，W2 依賴 W1，以此類推）

**本方法論擴展的**：
- 在 TDD 流程中的整合位置（Phase 3a）
- 與專家審查的協調機制
- 與 PM 的協作流程

### 3.3 與 Frontmatter Ticket 追蹤的關係

**狀態對應**：

| 本方法論階段 | Frontmatter 狀態 |
|------------|-----------------|
| Ticket 建立後 | `status: "pending"` |
| `/ticket-track claim` 後 | `status: "in_progress"` |
| `/ticket-track complete` 後 | `status: "completed"` |

### 3.4 與 Ticket 設計派工的關係

**本方法論專注於**：
- 何時進行 Ticket 設計決策（Phase 3a）
- 如何判斷是否需要拆分（四大檢查）

**Ticket 設計派工方法論專注於**：
- 如何設計每個 Ticket 的 5W1H
- 如何派工和驗收

---

## 第四章：執行檢查清單

### 4.1 Phase 3a 開始時

- [ ] 讀取 Phase 2 測試設計
- [ ] 定義任務描述（動詞 + 目標）
- [ ] 執行四大檢查並記錄結果
- [ ] 輸出評估結論到工作日誌
- [ ] 如果任一檢查未通過，執行 /ticket-create

### 4.2 Ticket 拆分後執行時

- [ ] PM 審核所有 Tickets（確認單一職責）
- [ ] 建立 Ticket 索引到主版本日誌
- [ ] 按 Wave 順序執行 Tickets
- [ ] 每個 Ticket 開始前執行 /ticket-track claim
- [ ] 每個 Ticket 完成後執行 /ticket-track complete
- [ ] 每個 Ticket 完成後觸發即時 Review

### 4.3 Phase 4 評估時

- [ ] 確認所有 Tickets 已完成
- [ ] 執行跨 Ticket 重構評估
- [ ] 不產生新的 Tickets（除非發現新功能需求）

---

## 第五章：常見問題

### Q1: 如果任務很小（只需 10 分鐘），還需要做四大檢查嗎？

**A**: 是的。四大檢查的目的是確認職責是否單一，與任務大小無關。即使是小任務，如果包含多個目標，也應該拆分。

### Q2: 如果四大檢查都通過，但任務很大，怎麼辦？

**A**: 繼續執行。任務大小不是拆分的依據。只要職責單一，就不應拆分。如果確實很大，可以在 Phase 3b 中分多次實作，但不需要建立多個 Tickets。

### Q3: 拆分後的 Tickets 需要再次做四大檢查嗎？

**A**: 是的。每個拆分出來的 Ticket 都必須通過四大檢查，確保拆分後的每個任務也符合單一職責。

### Q4: Phase 4 重構時發現需要拆分，怎麼辦？

**A**: 不應在 Phase 4 新增 Tickets。如果發現需要重構的範圍太大，應該：
1. 完成當前版本的 Phase 4 評估
2. 建立新版本來處理重構需求
3. 在新版本的 Phase 3a 進行單一職責評估

### Q5: 如果在 Phase 3b 實作中發現需要拆分，怎麼辦？

**A**: 這表示 Phase 3a 的評估不完整。應該：
1. 暫停 Phase 3b 實作
2. 回到 Phase 3a 重新評估
3. 執行正確的 Ticket 拆分
4. 從拆分後的第一個 Ticket 重新開始

### Q6: 四大檢查中有一項不確定，怎麼辦？

**A**: 如果不確定是否通過某項檢查，**預設為未通過**，進行拆分。寧可過度拆分，也不要讓職責混亂的 Ticket 進入實作階段。

---

## 版本歷史

| 版本 | 日期 | 更新內容 |
|------|------|---------|
| v1.0.0 | 2025-12-29 | 初版，基於 UC-05 開發經驗和單一職責原則設計 |

---

**文件結束**
