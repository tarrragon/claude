# Ticket 生命週期管理方法論

**版本**: v1.0
**更新日期**: 2025-10-11
**適用範圍**: 敏捷重構開發流程中的 Ticket 全生命週期管理

---

## 方法論概述

### 問題背景

在敏捷開發過程中，Ticket 是承載開發任務的核心載體。然而，實務中常見以下生命週期管理問題：

**問題 1：狀態混亂**
- Ticket 狀態定義不明確，開發者不清楚當前應處於哪個階段
- 狀態流轉規則不清晰，導致 Ticket 在不同狀態間無序跳轉
- 缺乏明確的狀態進入/退出條件

**問題 2：建立標準不一致**
- Ticket 標題格式五花八門，無法快速理解任務性質
- 描述內容缺乏結構，關鍵資訊散落或遺失
- 驗收條件定義模糊，無法客觀判斷完成與否

**問題 3：執行流程不清**
- 開發者領取 Ticket 後不知從何下手
- 執行過程缺乏進度追蹤和問題記錄
- 自我檢查標準不明確，提交 Review 時機模糊

**問題 4：驗收標準主觀**
- 驗收條件描述抽象，無法客觀測量
- 不同 Reviewer 對相同條件有不同理解
- 缺乏統一的驗收標準參考框架

**問題 5：關閉條件不嚴謹**
- Ticket 未完全完成就被關閉
- 相關文檔和測試未同步更新
- 技術債務隨 Ticket 關閉而被忽略

### 方法論目標

本方法論建立**完整的 Ticket 生命週期管理體系**，確保：

1. **狀態清晰**：4 個明確定義的狀態和清晰的流轉規則
2. **標準統一**：標準化的 Ticket 建立模板和 5 個核心欄位
3. **流程明確**：6 個步驟的執行流程和具體操作指引
4. **驗收客觀**：基於 SMART 原則的驗收標準制定方法
5. **關閉嚴謹**：5 項強制條件確保 Ticket 完全完成

### 核心原則

**原則 1：狀態驅動流程**
- Ticket 狀態決定當前階段和可執行動作
- 狀態流轉遵循明確的進入/退出條件
- 狀態變更必須記錄和可追溯

**原則 2：模板標準化**
- 所有 Ticket 使用統一建立模板
- 5 個核心欄位缺一不可
- 標題格式遵循「動詞 + 目標」結構

**原則 3：驗收可測量**
- 驗收條件符合 SMART 原則
- 每個條件可客觀檢查和打勾
- 避免主觀描述和模糊用語

**原則 4：快速流轉**
- Ticket 在各狀態間快速流轉
- 避免長時間停留在單一狀態
- 問題發現立即處理，不累積

**原則 5：完整關閉**
- 關閉前檢查所有強制條件
- 相關文檔和測試同步更新
- 無技術債務殘留

### 適用場景

本方法論適用於以下開發場景：

**場景 1：敏捷開發團隊**
- 需要明確的任務管理流程
- 需要快速迭代和頻繁交付
- 需要清晰的進度追蹤

**場景 2：遠端協作團隊**
- 團隊成員分散各地
- 需要明確的狀態和驗收標準
- 需要異步協作和進度同步

**場景 3：大型專案管理**
- Ticket 數量眾多，需要系統化管理
- 需要明確的依賴關係和執行順序
- 需要可追溯的完成記錄

**場景 4：品質要求嚴格的專案**
- 需要完整的驗收和關閉檢查
- 需要確保無技術債務累積
- 需要文檔和測試完整性

### 方法論結構

本方法論包含以下章節：

- **第一章**：Ticket 狀態定義與流轉 - 定義 4 個狀態和流轉規則
- **第二章**：Ticket 建立標準與規範 - 標題格式、描述內容、5 個核心欄位
- **第三章**：Ticket 執行流程詳解 - 6 個步驟從領取到提交 Review
- **第四章**：Ticket 驗收標準（SMART原則）- 制定可測量的驗收條件
- **第五章**：Ticket 關閉條件與檢查 - 5 項強制條件和 3 項建議條件
- **第六章**：生命週期管理最佳實踐 - 實務案例和常見問題處理
- **附錄**：術語表、快速參考、整合指引

---

## 第一章：Ticket 狀態定義與流轉

### 1.1 Ticket 四狀態模型

Ticket 從建立到關閉經歷 4 個明確定義的狀態，每個狀態有清晰的進入條件、可執行動作、和退出條件。

#### 狀態 1：待執行（Pending）

**狀態定義**：

Ticket 已建立並通過準備度檢查，等待開發者領取執行。此狀態代表 Ticket 已準備就緒，但尚未開始實際開發工作。

**進入條件**（3 項）：

1. **Ticket 建立完成**：
   - 標題格式正確（動詞 + 目標）
   - 5 個核心欄位完整（背景、目標、步驟、驗收條件、參考文件）
   - 驗收條件符合 SMART 原則

2. **驗收條件明確**：
   - 至少 3 個可驗證的驗收條件
   - 每個條件客觀可檢查
   - 使用 checkbox 格式便於追蹤

3. **依賴 Ticket 已完成**（如適用）：
   - 所有前置依賴 Ticket 狀態為「已完成」
   - 無阻塞性依賴問題
   - 可立即開始執行

**可執行動作**（3 項）：

1. **指派開發者**：
   - 根據開發者技能和負載分配
   - 確保開發者理解 Ticket 目標
   - 通知開發者並說明優先級

2. **調整優先級**：
   - 根據業務需求變化調整
   - 考慮依賴關係和阻塞影響
   - 與團隊溝通優先級變更原因

3. **開始執行**：
   - 開發者領取 Ticket
   - 標記狀態為「進行中」
   - 記錄開始時間

**退出條件**（1 項）：

- 開發者開始執行 → 轉為「進行中」狀態

**流程特性**：

- **快速流轉**：Ticket 不應長時間停留在待執行狀態
- **依賴優先**：優先處理無依賴或依賴已滿足的 Ticket
- **負載平衡**：考慮團隊成員負載，避免單點瓶頸

---

#### 狀態 2：進行中（In Progress）

**狀態定義**：

開發者正在積極執行 Ticket，進行程式碼撰寫、測試編寫、文檔更新等開發活動。此狀態代表 Ticket 處於活躍開發階段。

**進入條件**（2 項）：

1. **開發者領取 Ticket**：
   - 開發者主動領取或被指派
   - 開發者確認理解 Ticket 目標和步驟
   - 開發者確認有足夠時間投入

2. **標記 Ticket 為進行中**：
   - 更新 Ticket 狀態
   - 記錄開始時間
   - 通知相關人員（如 PM、Reviewer）

**可執行動作**（4 項）：

1. **持續更新進度**：
   - 定期更新 Ticket 進度（如每完成一個步驟）
   - 記錄已完成的步驟和剩餘工作
   - 更新預估完成時間

2. **記錄問題到 Ticket 日誌**：
   - 遇到技術問題立即記錄
   - 記錄問題描述、嘗試解決方案、最終解決方法
   - 標註是否需要外部協助

3. **完成後提交 Review**：
   - 自我檢查所有驗收條件
   - 確認所有步驟已完成
   - 標記狀態為「Review 中」

4. **發現問題暫停**：
   - 遇到阻塞性問題無法繼續
   - 轉回「待執行」狀態
   - 記錄暫停原因和恢復條件

**退出條件**（2 項）：

1. **完成執行 → 轉為「Review 中」**：
   - 開發者認為已完成所有工作
   - 自我檢查通過
   - 提交 Review 請求

2. **遇到阻塞 → 轉回「待執行」**：
   - 發現無法解決的技術問題
   - 依賴條件改變
   - 需求變更或 Ticket 重新評估

**流程特性**：

- **快速完成**：Ticket 應在合理時間內完成（建議 ≤ 8 小時）
- **即時記錄**：問題和進度應即時記錄，不延遲
- **自我檢查**：提交 Review 前必須完成自我驗收檢查

---

#### 狀態 3：Review 中（In Review）

**狀態定義**：

Ticket 已完成開發工作，等待 Reviewer 檢查驗收。此狀態代表開發者認為工作已完成，但需要獨立第三方驗證。

**進入條件**（2 項）：

1. **開發者認為已完成**：
   - 所有步驟執行完畢
   - 自我檢查通過
   - 信心認為滿足所有驗收條件

2. **提交 Review 請求**：
   - 標記 Ticket 為「Review 中」
   - 通知 Reviewer
   - 附上 Review 檢查清單

**可執行動作**（3 項）：

1. **Review 檢查驗收條件**：
   - Reviewer 逐項檢查驗收條件
   - 執行相關測試驗證功能
   - 檢查程式碼品質和規範遵循

2. **通過驗收 → 轉為「已完成」**：
   - 所有驗收條件滿足
   - 測試 100% 通過
   - 程式碼品質符合標準
   - 標記 Ticket 為「已完成」

3. **發現問題 → 轉回「進行中」**：
   - 驗收條件未滿足
   - 測試失敗或程式碼品質不符
   - 建立修正 Ticket（如需要）
   - 提供明確的修正指引

**退出條件**（2 項）：

1. **Review 通過 → 轉為「已完成」**
2. **Review 未通過 → 轉回「進行中」**

**流程特性**：

- **快速 Review**：Review 應在 1-2 小時內完成，避免阻塞開發流程
- **聚焦驗收條件**：Review 重點是驗證驗收條件，不擴大範圍
- **明確反饋**：Review 未通過時提供具體的修正指引

---

#### 狀態 4：已完成（Completed）

**狀態定義**：

Ticket 通過 Review 驗收，所有工作已完成並符合品質標準，Ticket 正式關閉並歸檔。

**進入條件**（3 項）：

1. **所有驗收條件滿足**：
   - 逐項檢查 checkbox 全部打勾
   - 功能實作完整且正確
   - 無遺漏項目

2. **Review 通過**：
   - Reviewer 確認驗收
   - 無需進一步修正
   - Review 意見已全部處理

3. **相關測試 100% 通過**：
   - Unit tests 全部通過
   - Integration tests 全部通過
   - Widget tests（如適用）全部通過
   - dart analyze 0 錯誤

**可執行動作**（3 項）：

1. **更新主版本日誌 Ticket 索引**：
   - 在主版本工作日誌中記錄 Ticket 完成
   - 更新 Ticket 索引表
   - 連結 Ticket 詳細記錄

2. **更新 todolist 任務狀態**：
   - 標記相關 todolist 項目為完成
   - 更新依賴此 Ticket 的其他任務狀態
   - 檢查是否觸發新的待執行任務

3. **記錄完成時間和實際工時**：
   - 記錄完成時間戳
   - 計算實際工時（開始時間 → 完成時間）
   - 與預估工時比較，用於未來估算改進

**停留時間**：

- **永久停留**：已完成的 Ticket 不會再改變狀態
- **歸檔管理**：定期歸檔舊 Ticket，保持活躍 Ticket 列表清晰
- **可追溯性**：歸檔後仍可查詢和參考

**流程特性**：

- **最終狀態**：Ticket 達到最終狀態，不再流轉
- **完整記錄**：所有資訊（工時、問題、解決方案）完整保留
- **知識沉澱**：成為未來相似任務的參考資料

### 1.2 狀態流轉規則

#### 標準流轉路徑

```text
建立 Ticket
    ↓
待執行（Pending）
    ↓
    開發者領取
    ↓
進行中（In Progress）
    ↓
    自我檢查通過
    ↓
Review 中（In Review）
    ↓
    Review 檢查
    ↓
  通過？
    ├─ Yes → 已完成（Completed）[終點]
    └─ No  → 進行中（In Progress）[修正循環]
```

#### 循環修正機制

**修正循環觸發條件**：

當 Review 發現以下問題時，Ticket 返回「進行中」狀態：

1. **驗收條件未滿足**：
   - 功能實作不完整
   - 行為與預期不符
   - 邊界條件未處理

2. **測試失敗**：
   - Unit tests 失敗
   - Integration tests 失敗
   - 測試覆蓋率不足

3. **程式碼品質問題**：
   - dart analyze 有錯誤或警告
   - 違反專案規範
   - 程式碼可讀性差

**修正循環處理原則**：

1. **建立修正 Ticket**（建議）：
   - 對於較大的修正需求，建立新的修正 Ticket
   - 明確描述需要修正的問題
   - 設定依賴關係（修正 Ticket 依賴原 Ticket）

2. **直接修正**（小問題）：
   - 對於小問題（如格式、命名），可直接修正
   - 修正後重新提交 Review
   - 記錄修正內容到 Ticket 日誌

3. **避免無限循環**：
   - 限制修正循環次數（建議 ≤ 2 次）
   - 超過限制需重新評估 Ticket 設計
   - 考慮是否需要拆分為更小的 Ticket

#### 異常流轉路徑

**暫停場景**：

```text
進行中（In Progress）
    ↓
    遇到阻塞問題
    ↓
待執行（Pending）
    ↓
    問題解決後
    ↓
進行中（In Progress）
```

**暫停原因範例**：
- 依賴的 API 未就緒
- 需求變更需要重新設計
- 技術問題需要外部協助
- 資源不足（如測試環境）

**取消場景**：

某些情況下，Ticket 可能需要被取消（不經過完成狀態）：

- 需求變更，Ticket 不再需要
- 發現重複 Ticket
- 技術方案變更，Ticket 設計過時

**取消處理**：
- 標記 Ticket 為「已取消」（特殊狀態）
- 記錄取消原因
- 更新依賴此 Ticket 的其他任務

### 1.3 狀態管理最佳實踐

#### 實踐 1：狀態可視化

**目標**：團隊成員一眼就能看到所有 Ticket 的當前狀態和分佈。

**實作方式**：

使用看板（Kanban）或任務管理工具，將 Ticket 按狀態分欄顯示：

```text
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ 待執行       │ 進行中       │ Review 中    │ 已完成       │
│ (Pending)    │ (In Progress)│ (In Review)  │ (Completed)  │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ Ticket #5    │ Ticket #1    │ Ticket #3    │ Ticket #2    │
│ Ticket #6    │ Ticket #4    │              │ Ticket #7    │
│ Ticket #8    │              │              │ Ticket #9    │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

**效益**：
- 快速識別瓶頸（如「Review 中」累積過多）
- 負載平衡（「進行中」不應過多）
- 進度透明（團隊和 stakeholder 都能看到）

#### 實踐 2：狀態同步通知

**目標**：狀態變更時，相關人員即時收到通知。

**通知時機和對象**：

| 狀態變更 | 通知對象 | 通知內容 |
|---------|---------|---------|
| Pending → In Progress | PM、團隊 | 開發者開始執行 Ticket #N |
| In Progress → In Review | Reviewer | Ticket #N 提交 Review 請求 |
| In Review → Completed | 開發者、PM | Ticket #N Review 通過 |
| In Review → In Progress | 開發者 | Ticket #N Review 未通過，需修正 |

**效益**：
- 減少溝通成本
- 避免 Ticket 被遺忘
- 提高響應速度

#### 實踐 3：限制 WIP（Work In Progress）

**目標**：限制同時進行中的 Ticket 數量，避免並行過多導致完成率下降。

**WIP 限制建議**：

- **個人 WIP**：每位開發者同時只處理 1-2 個 Ticket
- **團隊 WIP**：團隊「進行中」Ticket 數量 ≤ 團隊人數 × 1.5
- **Review WIP**：「Review 中」Ticket 數量 ≤ 3（避免 Review 瓶頸）

**效益**：
- 提高完成率（Focus on completion, not starting）
- 減少上下文切換成本
- 更快交付價值

#### 實踐 4：定期狀態檢視

**目標**：定期檢視 Ticket 狀態分佈，識別和解決流程問題。

**檢視頻率**：
- **每日檢視**（Daily Standup）：快速過一遍所有活躍 Ticket
- **每週檢視**（Weekly Review）：深入分析狀態分佈和流轉速度

**檢視指標**：

1. **週期時間**（Cycle Time）：
   - 從「進行中」到「已完成」的平均時間
   - 目標：≤ 1 天（8 小時）

2. **等待時間**（Wait Time）：
   - 「待執行」狀態停留時間
   - 「Review 中」狀態停留時間
   - 目標：≤ 2 小時

3. **返工率**（Rework Rate）：
   - Review 未通過返回「進行中」的比例
   - 目標：≤ 20%

**效益**：
- 及早發現流程瓶頸
- 數據驅動的流程改進
- 提高團隊整體效率

---

## 第二章：Ticket 建立標準與規範

### 2.1 Ticket 標題格式

#### 標題結構

**標準格式**：`Ticket #N: [動詞] [目標]`

**格式說明**：

1. **Ticket #N**：
   - N 為 Ticket 編號，從 1 開始遞增
   - 編號在專案或版本內唯一
   - 便於引用和追蹤

2. **動詞**：
   - 清楚表達任務性質（定義、撰寫、實作、整合、修復、重構）
   - 使用主動語態
   - 避免模糊動詞（如「處理」、「做」）

3. **目標**：
   - 明確描述要達成的結果
   - 使用具體名詞（如 Interface 名稱、檔案名稱）
   - 避免籠統描述（如「相關功能」、「一些測試」）

#### 動詞選擇指引

**定義（Define）**：

適用於建立介面、定義資料結構、制定規範等抽象層級工作。

**範例**：
- ✅ `Ticket #1: 定義 IBookRepository 介面`
- ✅ `Ticket #5: 定義 BookEntity 資料結構`
- ✅ `Ticket #8: 定義錯誤處理規範`

**撰寫（Write）**：

適用於編寫測試、撰寫文檔、撰寫規格等文字性工作。

**範例**：
- ✅ `Ticket #2: 撰寫 BookRepository 單元測試`
- ✅ `Ticket #6: 撰寫 API 整合文檔`
- ✅ `Ticket #9: 撰寫使用者手冊`

**實作（Implement）**：

適用於具體實現介面、建立元件、開發功能等實作工作。

**範例**：
- ✅ `Ticket #3: 實作 SQLiteBookRepository`
- ✅ `Ticket #7: 實作書籍搜尋功能`
- ✅ `Ticket #10: 實作使用者認證模組`

**整合（Integrate）**：

適用於連接模組、整合服務、對接 API 等整合工作。

**範例**：
- ✅ `Ticket #4: 整合 BookRepository 到 UseCase`
- ✅ `Ticket #11: 整合 Google Books API`
- ✅ `Ticket #15: 整合第三方支付服務`

**修復（Fix）**：

適用於修復 Bug、解決問題、處理錯誤等修正工作。

**範例**：
- ✅ `Ticket #12: 修復書籍新增失敗 Bug`
- ✅ `Ticket #16: 修復測試覆蓋率不足問題`
- ✅ `Ticket #20: 修復 iOS 相容性問題`

**重構（Refactor）**：

適用於改善程式碼結構、優化效能、消除技術債務等重構工作。

**範例**：
- ✅ `Ticket #13: 重構 BookRepository 錯誤處理`
- ✅ `Ticket #17: 重構 UI 元件結構`
- ✅ `Ticket #21: 重構資料庫查詢邏輯`

#### 標題範例對比

**✅ 良好範例**：

```markdown
Ticket #1: 定義 IBookRepository 介面
Ticket #2: 撰寫 BookRepository 單元測試
Ticket #3: 實作 SQLiteBookRepository
Ticket #4: 整合 BookRepository 到 GetBookUseCase
Ticket #5: 修復書籍新增失敗 Bug
Ticket #6: 重構 BookRepository 錯誤處理
```

**❌ 不良範例及改進**：

```markdown
❌ Ticket #1: BookRepository
改進 → Ticket #1: 定義 IBookRepository 介面

❌ 做一下 Repository
改進 → Ticket #2: 實作 SQLiteBookRepository

❌ 處理書籍相關功能
改進 → Ticket #3: 實作書籍搜尋功能

❌ 修復一些問題
改進 → Ticket #4: 修復書籍新增失敗 Bug

❌ 優化程式碼
改進 → Ticket #5: 重構 BookRepository 錯誤處理
```

### 2.2 Ticket 描述內容 - 五核心欄位

完整的 Ticket 必須包含以下 5 個核心欄位，缺一不可。

#### 建立模板

```markdown
## Ticket #N: [動詞] [目標]

### 1. 背景（Background）
[為什麼需要這個 Ticket？來自哪個需求或問題？]

### 2. 目標（Objective）
[這個 Ticket 要達成什麼？明確且可驗證的目標描述]

### 3. 步驟（Steps）
1. [具體執行步驟 1]
2. [具體執行步驟 2]
3. [具體執行步驟 3]
4. [具體執行步驟 4]
5. [具體執行步驟 5]

### 4. 驗收條件（Acceptance Criteria）
- [ ] [可驗證的條件 1]
- [ ] [可驗證的條件 2]
- [ ] [可驗證的條件 3]
- [ ] [可驗證的條件 4]

### 5. 參考文件（References）
- [設計文件連結或路徑]
- [需求規格連結或路徑]
- [相關技術文檔連結]

### 6. 依賴 Ticket（Dependencies，選填）
- Ticket #X: [描述] (必須先完成)
- Ticket #Y: [描述] (可並行執行)
```

#### 欄位 1：背景（Background）

**目的**：提供上下文，說明為什麼需要這個 Ticket。

**內容要求**：

1. **需求來源**：
   - 連結到需求規格（如 `docs/app-requirements-spec.md` 第 X 章節）
   - 引用使用者故事或用例（如 `UC-003: 查詢書籍資訊`）
   - 說明業務價值或技術必要性

2. **問題描述**：
   - 當前存在什麼問題或缺口
   - 為什麼現有方案不足
   - 這個 Ticket 如何解決問題

3. **上下文資訊**：
   - 相關的架構決策
   - 技術選型考量
   - 與其他模組的關係

**範例（良好）**：

```markdown
### 1. 背景

根據需求規格 `docs/app-requirements-spec.md` 第 3.2 節，應用程式需要支援
書籍資訊的持久化儲存。當前架構中，Domain Layer 已定義 `IBookRepository`
介面（見 `lib/domains/library/interfaces/i_book_repository.dart`），但缺少
具體的 SQLite 實作。

本 Ticket 實作 SQLite 版本的 BookRepository，作為 Infrastructure Layer
的核心元件，負責書籍資料的 CRUD 操作。
```

**範例（不良）**：

```markdown
❌ 需要做 Repository
❌ 老闆說要加這個功能
❌ 就是要實作一下
```

#### 欄位 2：目標（Objective）

**目的**：一句話說明 Ticket 要達成什麼，必須明確且可驗證。

**內容要求**：

1. **簡潔明確**：
   - 一句話說明（建議 ≤ 30 字）
   - 使用主動語態
   - 避免模糊用語

2. **可驗證**：
   - 目標達成與否可客觀判斷
   - 避免主觀描述（如「良好」、「優化」）
   - 結合驗收條件可完整驗證

3. **範圍明確**：
   - 清楚界定做什麼、不做什麼
   - 避免範圍模糊或過大
   - 符合單一職責原則

**範例（良好）**：

```markdown
### 2. 目標

實作 `SQLiteBookRepository` 類別，提供書籍資料的 CRUD 操作，
符合 `IBookRepository` 介面規範，並通過所有單元測試。
```

**範例（不良）**：

```markdown
❌ 做好 Repository
❌ 完成書籍相關功能
❌ 優化資料儲存效能
```

#### 欄位 3：步驟（Steps）

**目的**：列出具體執行步驟，幫助開發者快速理解如何執行。

**內容要求**：

1. **步驟數量**：
   - 建議 3-5 個步驟
   - 每個步驟可獨立驗證
   - 步驟間有邏輯順序

2. **步驟描述**：
   - 使用動詞開頭（建立、撰寫、實作、測試）
   - 具體指明操作對象（檔案、類別、方法）
   - 包含必要的技術細節

3. **可操作性**：
   - 開發者按步驟執行即可完成 Ticket
   - 避免過於抽象的描述
   - 提供具體的檔案路徑或程式碼位置

**範例（良好）**：

```markdown
### 3. 步驟

1. 建立 `lib/infrastructure/database/repositories/sqlite_book_repository.dart` 檔案
2. 實作 `SQLiteBookRepository` 類別，繼承 `IBookRepository` 介面
3. 實作 `create()` 方法：插入書籍資料到 SQLite 資料庫
4. 實作 `getById()` 方法：根據 ID 查詢書籍資料
5. 實作 `update()` 和 `delete()` 方法
6. 撰寫單元測試 `test/infrastructure/database/repositories/sqlite_book_repository_test.dart`
7. 執行測試確保 100% 通過
```

**範例（不良）**：

```markdown
❌ 寫程式碼
❌ 做測試
❌ 完成功能
```

#### 欄位 4：驗收條件（Acceptance Criteria）

**目的**：列出所有可驗證的條件，作為 Ticket 完成的客觀標準。

**內容要求**：

1. **條件數量**：
   - 建議 3-5 個條件
   - 覆蓋功能、測試、品質三個維度
   - 每個條件可獨立檢查

2. **可驗證性**：
   - 每個條件可打勾確認
   - 使用客觀標準（如測試通過、錯誤數為 0）
   - 避免主觀描述（如「程式碼品質好」）

3. **完整性**：
   - 覆蓋 Ticket 目標的所有面向
   - 包含功能正確性、測試覆蓋、程式碼品質
   - 與步驟對應，確保步驟完成 = 條件滿足

**格式**：
- 使用 checkbox 格式：`- [ ]`
- 每個條件一行
- Review 時逐項打勾

**範例（良好）**：

```markdown
### 4. 驗收條件

- [ ] `SQLiteBookRepository` 類別實作完成，符合 `IBookRepository` 介面
- [ ] `create()` 方法正確插入書籍資料，回傳新增的 Book 物件
- [ ] `getById()` 方法正確查詢書籍資料，找不到時拋出 `BookNotFoundException`
- [ ] `update()` 和 `delete()` 方法實作完成且功能正確
- [ ] 單元測試覆蓋所有 CRUD 方法，測試通過率 100%
- [ ] `dart analyze` 0 錯誤，程式碼符合專案規範
```

**範例（不良）**：

```markdown
❌ 功能運作正常
❌ 測試通過
❌ 程式碼品質良好
```

#### 欄位 5：參考文件（References）

**目的**：連結到設計文件、需求規格、相關 Ticket，提供完整資訊。

**內容要求**：

1. **設計文件**：
   - 架構設計文檔
   - API 規格文檔
   - 資料模型文檔

2. **需求規格**：
   - 需求規格書相關章節
   - 使用者故事或用例
   - 業務邏輯說明

3. **相關 Ticket**：
   - 依賴的 Ticket（必須先完成）
   - 相關的 Ticket（提供背景資訊）
   - 後續的 Ticket（說明整體規劃）

**範例（良好）**：

```markdown
### 5. 參考文件

- 需求規格：`docs/app-requirements-spec.md` 第 3.2 節「資料持久化」
- 架構設計：`docs/domain-transformation-layer-design.md` 第 4 章「Repository Pattern」
- 介面定義：`lib/domains/library/interfaces/i_book_repository.dart`
- 相關 Ticket：
  - Ticket #1: 定義 IBookRepository 介面（已完成）
  - Ticket #3: 整合 SQLiteBookRepository 到 GetBookUseCase（待執行）
```

**範例（不良）**：

```markdown
❌ 參考之前的程式碼
❌ 看文檔
❌ 問 PM
```

#### 欄位 6：依賴 Ticket（Dependencies，選填）

**目的**：明確 Ticket 間的依賴關係，確保執行順序正確。

**內容要求**：

1. **強依賴（必須先完成）**：
   - 列出必須先完成的 Ticket
   - 說明依賴原因（如需要先定義介面）
   - 標註：`(必須先完成)` 或 `(Blocking)`

2. **弱依賴（可並行）**：
   - 列出相關但可並行的 Ticket
   - 說明關聯性（如同屬一個功能模組）
   - 標註：`(可並行)` 或 `(Parallel)`

**範例（良好）**：

```markdown
### 6. 依賴 Ticket

**強依賴**：
- Ticket #1: 定義 IBookRepository 介面 (必須先完成)
  - 原因：實作類別需要依賴介面定義

**弱依賴**：
- Ticket #2: 撰寫 BookRepository 單元測試 (可並行)
  - 關聯：測試和實作可並行開發，最後整合
```

### 2.3 Ticket 建立檢查清單

在建立 Ticket 前，使用以下檢查清單確保 Ticket 符合標準：

#### 標題檢查（3 項）

- [ ] 標題格式：`Ticket #N: [動詞] [目標]`
- [ ] 動詞選擇正確（定義、撰寫、實作、整合、修復、重構）
- [ ] 目標描述具體明確，無模糊用語

#### 內容檢查（5 項）

- [ ] 背景欄位完整，說明需求來源和上下文
- [ ] 目標欄位簡潔明確（≤ 30 字），可驗證
- [ ] 步驟欄位具體可操作（3-5 個步驟）
- [ ] 驗收條件符合 SMART 原則（3-5 個條件）
- [ ] 參考文件完整，連結到設計和需求文檔

#### 驗收條件檢查（5 項）

- [ ] 每個條件可客觀驗證（可打勾確認）
- [ ] 條件覆蓋功能、測試、品質三個維度
- [ ] 避免主觀描述（如「良好」、「優化」）
- [ ] 使用 checkbox 格式 `- [ ]`
- [ ] 與步驟對應，步驟完成 = 條件滿足

#### 依賴關係檢查（3 項）

- [ ] 強依賴 Ticket 已明確標註
- [ ] 弱依賴 Ticket 已說明關聯性
- [ ] 依賴關係不循環（A 依賴 B，B 不能依賴 A）

---

## 第三章：Ticket 執行流程詳解

### 3.1 執行流程六步驟

Ticket 執行流程包含 6 個明確步驟，從領取 Ticket 到提交 Review，確保開發過程系統化和可追蹤。

#### 步驟 1：領取 Ticket

**目標**：開發者從「待執行」清單中選擇合適的 Ticket，並標記為「進行中」。

**執行動作**（3 項）：

1. **檢查依賴 Ticket**：
   - 查看 Ticket 的「依賴 Ticket」欄位
   - 確認所有強依賴 Ticket 狀態為「已完成」
   - 如有未完成依賴，選擇其他 Ticket 或等待依賴完成

2. **評估工作量和優先級**：
   - 檢查 Ticket 步驟和驗收條件，評估工作量
   - 確認自己有足夠時間完成（建議一次領取 ≤ 8 小時工作量）
   - 考慮 Ticket 優先級和緊急程度

3. **標記 Ticket 為「進行中」**：
   - 更新 Ticket 狀態
   - 記錄開始時間
   - 通知 PM 和相關人員

**檢查清單**：

- [ ] 依賴 Ticket 已全部完成
- [ ] 理解 Ticket 目標和步驟
- [ ] 預估可在合理時間內完成
- [ ] 已標記為「進行中」並記錄開始時間

---

#### 步驟 2：閱讀 Ticket

**目標**：深入理解 Ticket 的背景、目標、步驟、驗收條件，確保執行方向正確。

**執行動作**（4 項）：

1. **閱讀背景和目標**：
   - 理解為什麼需要這個 Ticket（背景）
   - 明確要達成什麼（目標）
   - 確認目標與自己的理解一致

2. **檢查參考文件**：
   - 開啟並閱讀所有參考文件
   - 理解設計決策和架構考量
   - 查看相關 Ticket 的實作方式（如適用）

3. **理解步驟和驗收條件**：
   - 逐步閱讀執行步驟
   - 理解每個驗收條件的具體要求
   - 確認自己能滿足所有條件

4. **識別潛在問題**：
   - 思考可能遇到的技術挑戰
   - 確認所需的資源和工具可用
   - 如有疑問，立即詢問 Ticket 建立者或 PM

**檢查清單**：

- [ ] 理解 Ticket 背景和目標
- [ ] 閱讀所有參考文件
- [ ] 理解每個步驟和驗收條件
- [ ] 識別潛在問題並確認可解決

---

#### 步驟 3：執行步驟

**目標**：按照 Ticket 步驟逐步執行，持續更新進度，遇到問題即時記錄。

**執行動作**（5 項）：

1. **按步驟執行**：
   - 從第一步開始，逐步完成
   - 每完成一步，在步驟旁標註 ✅
   - 不跳過步驟，確保順序正確

2. **持續更新進度**：
   - 完成步驟後更新 Ticket 進度（如「已完成步驟 1-3」）
   - 更新預估完成時間
   - 讓 PM 和團隊了解當前進度

3. **遇到問題立即記錄**：
   - 在 Ticket 日誌中記錄問題描述
   - 記錄嘗試的解決方案
   - 如需外部協助，標註並通知相關人員

4. **執行測試**：
   - 撰寫單元測試（如步驟要求）
   - 執行測試確保功能正確
   - 測試失敗時修正並重新測試

5. **遵循專案規範**：
   - 遵循程式碼風格指南
   - 使用專案標準的錯誤處理機制
   - 遵循命名規範和檔案組織結構

**問題記錄範例**：

```markdown
### 執行日誌

**2025-10-11 14:30** - 步驟 1-2 完成 ✅
- 建立 `sqlite_book_repository.dart` 檔案
- 實作 `create()` 方法

**2025-10-11 15:00** - 遇到問題 ⚠️
- 問題：`create()` 方法執行時拋出 `SQLiteDatabaseException`
- 嘗試方案 1：檢查資料庫連線，發現連線正常
- 嘗試方案 2：檢查 SQL 語法，發現 ISBN 欄位型別錯誤
- 解決方案：修正 ISBN 欄位為 TEXT 型別 ✅

**2025-10-11 15:30** - 步驟 3-4 完成 ✅
- 實作 `getById()` 方法
- 撰寫單元測試，所有測試通過
```

**檢查清單**：

- [ ] 按步驟順序執行，不跳過
- [ ] 每完成一步標註 ✅
- [ ] 遇到問題立即記錄，包含問題描述和解決方案
- [ ] 執行測試並確保通過
- [ ] 遵循專案規範

---

#### 步驟 4：自我檢查

**目標**：提交 Review 前，自我檢查所有驗收條件，確保 Ticket 完全完成。

**執行動作**（4 項）：

1. **逐項檢查驗收條件**：
   - 逐項檢查每個驗收條件
   - 能滿足的條件打勾 ✅
   - 不能滿足的條件記錄原因並修正

2. **執行相關測試**：
   - 執行 Ticket 相關的所有測試
   - 確保測試 100% 通過
   - 執行 `dart analyze` 確保 0 錯誤

3. **檢查程式碼品質**：
   - 檢查程式碼風格是否符合規範
   - 檢查命名是否清晰明確
   - 檢查是否有未使用的程式碼或 import

4. **檢查文檔同步**：
   - 如修改 API 或介面，確保文檔同步更新
   - 如新增功能，確保使用者文檔或開發文檔更新
   - 檢查註解是否完整且正確

**自我檢查清單**：

```markdown
### 自我檢查

#### 驗收條件檢查
- [ ] 條件 1：SQLiteBookRepository 類別實作完成 ✅
- [ ] 條件 2：create() 方法功能正確 ✅
- [ ] 條件 3：getById() 方法功能正確 ✅
- [ ] 條件 4：update() 和 delete() 方法實作完成 ✅
- [ ] 條件 5：單元測試 100% 通過 ✅
- [ ] 條件 6：dart analyze 0 錯誤 ✅

#### 測試檢查
- [ ] 單元測試全部通過 ✅
- [ ] 測試覆蓋所有方法 ✅
- [ ] 測試包含邊界條件和錯誤處理 ✅

#### 程式碼品質檢查
- [ ] 程式碼風格符合規範 ✅
- [ ] 命名清晰明確 ✅
- [ ] 無未使用的程式碼或 import ✅
- [ ] 註解完整且正確 ✅

#### 文檔檢查
- [ ] API 文檔同步更新（如適用）✅
- [ ] 使用者文檔同步更新（如適用）N/A
```

**檢查清單**：

- [ ] 所有驗收條件已逐項檢查並打勾
- [ ] 相關測試 100% 通過
- [ ] `dart analyze` 0 錯誤
- [ ] 程式碼品質符合規範
- [ ] 相關文檔已同步更新

---

#### 步驟 5：提交 Review

**目標**：自我檢查通過後，標記所有驗收條件為完成，提交 Review 請求。

**執行動作**（3 項）：

1. **標記所有驗收條件為完成**：
   - 在 Ticket 中將所有驗收條件打勾 ✅
   - 確認無遺漏項目
   - 附上自我檢查清單

2. **標記 Ticket 為「Review 中」**：
   - 更新 Ticket 狀態為「Review 中」
   - 記錄提交 Review 時間
   - 記錄實際工時

3. **通知 Reviewer**：
   - 通知指定的 Reviewer
   - 說明 Ticket 已準備好 Review
   - 提供 Review 檢查清單（可選）

**提交 Review 訊息範例**：

```markdown
@Reviewer

Ticket #3 已完成開發，請 Review。

**完成摘要**：
- 實作 SQLiteBookRepository 類別，提供 CRUD 操作
- 撰寫單元測試，覆蓋所有方法，測試 100% 通過
- 程式碼符合專案規範，`dart analyze` 0 錯誤

**驗收條件**：
- [x] 所有 6 個驗收條件已滿足（見 Ticket）

**自我檢查**：
- [x] 驗收條件檢查通過
- [x] 測試檢查通過
- [x] 程式碼品質檢查通過
- [x] 文檔檢查通過

**實際工時**：6.5 小時（預估 8 小時）
```

**檢查清單**：

- [ ] 所有驗收條件已打勾 ✅
- [ ] Ticket 狀態已更新為「Review 中」
- [ ] 已通知 Reviewer
- [ ] 已記錄實際工時

---

#### 步驟 6：處理 Review 結果

**目標**：根據 Review 結果，完成 Ticket 關閉或進行修正。

**情況 1：Review 通過**

**執行動作**（3 項）：

1. **Ticket 標記為「已完成」**：
   - Reviewer 標記 Ticket 為「已完成」
   - 記錄完成時間
   - 記錄總工時（開始 → 完成）

2. **更新主版本日誌和 todolist**：
   - 在主版本工作日誌中記錄 Ticket 完成
   - 更新 todolist 相關任務狀態
   - 檢查是否觸發新的待執行任務

3. **慶祝完成**：
   - 與團隊分享完成成果
   - 總結經驗和學習
   - 準備領取下一個 Ticket

**情況 2：Review 未通過**

**執行動作**（4 項）：

1. **理解 Review 意見**：
   - 仔細閱讀 Reviewer 的意見
   - 理解未通過的原因
   - 如有疑問，與 Reviewer 溝通澄清

2. **評估修正範圍**：
   - 小問題：直接修正，重新提交 Review
   - 大問題：考慮建立修正 Ticket

3. **執行修正**：
   - 標記 Ticket 回到「進行中」狀態
   - 按 Review 意見修正
   - 記錄修正內容到 Ticket 日誌

4. **重新提交 Review**：
   - 修正完成後重新自我檢查
   - 再次提交 Review
   - 通知 Reviewer 已修正

**Review 未通過處理範例**：

```markdown
### Review 結果（2025-10-11 17:00）

**未通過原因**：
1. `create()` 方法未處理重複 ISBN 的情況 ❌
2. 單元測試缺少邊界條件測試（空字串、null 值）❌
3. 程式碼中有未使用的 import ❌

**修正計畫**：
- [ ] 修正 1：在 `create()` 方法中新增重複檢查邏輯
- [ ] 修正 2：補充邊界條件單元測試
- [ ] 修正 3：移除未使用的 import

**修正執行**（2025-10-11 17:30）：
- [x] 修正 1 完成：新增 `_checkDuplicateIsbn()` 方法 ✅
- [x] 修正 2 完成：新增 5 個邊界條件測試 ✅
- [x] 修正 3 完成：執行 `dart fix --apply` 清理 ✅

**重新提交 Review**（2025-10-11 18:00）
- 所有問題已修正
- 重新執行所有測試，100% 通過
- 請再次 Review
```

**檢查清單**：

**Review 通過**：
- [ ] Ticket 已標記為「已完成」
- [ ] 主版本日誌和 todolist 已更新
- [ ] 已記錄完成時間和總工時

**Review 未通過**：
- [ ] 理解 Review 意見
- [ ] 評估修正範圍（直接修正 vs 建立修正 Ticket）
- [ ] 執行修正並記錄到 Ticket 日誌
- [ ] 重新提交 Review

### 3.2 執行流程最佳實踐

#### 實踐 1：時間盒限制（Timeboxing）

**目標**：避免 Ticket 執行時間過長，保持快速迭代節奏。

**實作方式**：

- 每個 Ticket 設定時間盒（建議 ≤ 8 小時）
- 超過時間盒 50% 仍未完成 → 重新評估
- 考慮拆分為更小的 Ticket 或尋求協助

**效益**：
- 避免陷入複雜問題無法自拔
- 保持團隊節奏一致
- 及早發現估算偏差

#### 實踐 2：持續整合（Continuous Integration）

**目標**：每完成一個步驟就執行測試，避免問題累積。

**實作方式**：

- 完成步驟 1-2 → 執行相關測試
- 完成步驟 3-4 → 執行所有測試
- 提交 Review 前 → 執行完整測試套件

**效益**：
- 及早發現問題
- 減少除錯時間
- 提高程式碼品質

#### 實踐 3：問題即時記錄

**目標**：遇到問題立即記錄，保留完整的問題解決過程。

**實作方式**：

- 遇到問題 → 立即記錄到 Ticket 日誌
- 記錄問題描述、嘗試方案、最終解決方法
- 標註是否需要外部協助

**效益**：
- 保留知識，未來遇到相似問題可參考
- 幫助 Reviewer 理解執行過程
- 提供團隊學習素材

#### 實踐 4：自我 Review 嚴格執行

**目標**：提交 Review 前嚴格自我檢查，減少 Review 來回次數。

**實作方式**：

- 使用自我檢查清單
- 逐項檢查驗收條件
- 模擬 Reviewer 視角檢查程式碼

**效益**：
- 減少 Review 未通過次數
- 提高 Review 效率
- 建立個人品質意識

---

### 3.6 標準化工作日誌格式

**目標**：統一 Ticket 工作日誌格式，確保狀態追蹤清晰、驗收條件可驗證、協作溝通順暢。

#### 為什麼需要標準化格式？

**問題背景**：
- 工作日誌狀態標記不一致，導致進度誤判
- 驗收條件描述模糊，無法客觀判斷完成與否
- 缺少明確的協作檢查點，資訊傳遞不完整
- 缺少暫停點設計，容易遺漏關鍵檢查步驟

**標準化效益**：
- ✅ 狀態判定清晰：TDD Phase 1-4 獨立標記，總體狀態明確
- ✅ 驗收客觀可驗證：SMART 原則的可打勾檢查清單
- ✅ 協作溝通完整：明確的溝通檢查點和暫停點
- ✅ 防呆機制：清單使用模式降低人為疏忽

#### 標準模板參考

本專案提供兩個標準化工作日誌模板，根據任務複雜度選擇使用：

**1. 主版本工作日誌模板**：`.claude/templates/work-log-template.md`

**適用場景**：
- 包含多個 Ticket 的主版本任務（如 v0.12.I.0）
- 需要 TDD 四階段完整執行的複雜任務
- 需要主線程管理和代理人協作的任務

**核心欄位包含**：
1. **任務概述區塊**：任務編號、建立日期、狀態、完成日期、任務目標
2. **TDD 階段狀態**：Phase 1-4 獨立標記和總體狀態判定
3. **驗收條件**：Phase 1-4 各階段驗收條件 + 提交前驗收
4. **協作檢查點**：Phase 交接溝通確認（lavender → sage → pepper → cinnamon）
5. **驗收暫停點**：5 個關鍵暫停點（Phase 1-4 + 問題發現暫停點）
6. **清單使用模式**：DO-CONFIRM 或 READ-DO 模式選擇
7. **執行記錄**：各 Phase 詳細執行記錄、產出檔案、Review 記錄

**2. Ticket 工作日誌模板**：`.claude/templates/ticket-log-template.md`

**適用場景**：
- 單一明確的 Ticket 任務
- 從主版本任務拆分出的子任務
- 由單一執行代理人負責的獨立工作單元

**核心欄位包含**：
1. **Ticket 資訊區塊**：編號、類型、狀態、完成時間、優先級、預估工時
2. **5 個核心欄位**：背景、目標、步驟、驗收條件、參考文件
3. **TDD 階段狀態**：Phase 1-4 獨立標記和 Ticket 狀態判定
4. **協作檢查點**：Ticket 領取確認、Phase 交接確認、Review 提交確認
5. **驗收暫停點**：5 個 Ticket 特定暫停點（領取、Phase 2、Phase 3、Review 提交、Review 完成）
6. **清單使用模式**：DO-CONFIRM 或 READ-DO 模式說明
7. **執行記錄**：Ticket 時間軸、各 Phase 執行記錄、Review 記錄

**模板選擇決策**：

| 判斷標準 | 選擇模板 | 檔案命名 |
|---------|---------|---------|
| 任務包含多個 Ticket | work-log-template.md | vX.Y.Z-main.md |
| 單一 Ticket 任務 | ticket-log-template.md | vX.Y.Z-ticket-NNN.md |
| 複雜任務需 TDD 完整流程 | work-log-template.md | vX.Y.Z-task-description.md |
| 從主版本拆分的子任務 | ticket-log-template.md | vX.Y.Z-ticket-NNN.md |

#### TDD 階段狀態標記規範

**狀態表格格式**：

| TDD 階段 | 狀態 | 完成時間 | 備註 |
|---------|------|---------|------|
| **Phase 1** 設計 | ✅ 完成 | YYYY-MM-DD HH:MM | Ticket 建立即完成 Phase 1 |
| **Phase 2** 測試 | 🔄 進行中 | N/A | 測試案例數量：X 個 |
| **Phase 3** 實作 | ⏸️ 待開始 | N/A | 測試通過率：X/X |
| **Phase 4** 重構 | ⏸️ 待開始 | N/A | 重構項目：X 項 / 無需重構 |

**狀態圖示定義**：
- ✅ 完成：該階段已完成所有工作和驗收
- 🔄 進行中：該階段正在執行
- ⏸️ 待開始：該階段尚未開始
- ⏸️ 不適用：該 Ticket 類型不需要此階段（如文件任務無需測試）

#### Ticket 總體狀態判定規則

**基於 TDD 階段狀態表判定當前總體狀態**：

- ✅ **已完成並提交**：四階段全部完成 + git commit 已提交
- ✅ **已完成待提交**：四階段全部完成，等待 git commit
- 🔄 **Phase N 進行中**：正在執行 Phase N
- ⏸️ **已暫停**：因架構問題/依賴阻塞暫停
- ❌ **已取消**：不再執行，標記原因

**判定邏輯**：
1. 檢查 Phase 1-4 狀態欄
2. 找出最後一個「完成」的 Phase
3. 如果全部「完成」→ 檢查 git commit 狀態
4. 如果有「進行中」→ 標記該 Phase 進行中
5. 如果全部「待開始」→ Ticket 尚未執行

#### 驗收條件 SMART 原則

**SMART 驗收條件範例**：

```markdown
### 功能驗收
- [ ] 設計文件已建立（檔案路徑：`docs/work-logs/vX.Y.Z-design.md`）
- [ ] 測試案例設計完成（數量：15 個，覆蓋率：100%）
- [ ] 所有測試 100% 通過（15/15 通過）
- [ ] 程式碼實作完成（檔案：`lib/features/XXX.dart`, 200 行）

### 品質驗收
- [ ] `dart analyze` 0 錯誤 0 警告
- [ ] 程式碼符合專案品質標準（無 Code Smell）
- [ ] 無 TODO 或技術債務標記

### 文件驗收
- [ ] 工作日誌已更新完成記錄
- [ ] 主版本日誌 Ticket 索引已更新
- [ ] 相關文件已同步更新
```

**避免的錯誤範例**：
- ❌ 「功能正常運作」→ 無法客觀驗證
- ❌ 「程式碼品質良好」→ 標準不明確
- ❌ 「測試覆蓋率高」→ 無具體數值
- ✅ 「測試覆蓋率 ≥ 80%，包含 X 個正常流程和 Y 個異常處理測試」

#### 協作檢查點設計

**基於《清單革命》溝通進度表原則**：

> "這張表單叫做「溝通進度表」，也是一種清單，但追蹤的不是工程本身，而是溝通的進行狀況。"

**Ticket 特定協作檢查點**：

1. **Ticket 領取確認**：
   - [ ] 已閱讀並理解 Ticket 背景和目標
   - [ ] 已確認所有依賴 Ticket 狀態
   - [ ] 已確認參考文件可存取
   - [ ] 已標記 Ticket 狀態為「進行中」

2. **Phase 交接溝通確認**：
   - [ ] 前一階段產出已完整記錄到工作日誌
   - [ ] 下一階段代理人已閱讀前一階段產出
   - [ ] 有疑問或不明確處已提出並解答
   - [ ] 主線程已確認可以繼續下一階段

3. **Review 提交確認**：
   - [ ] 所有步驟執行追蹤已打勾
   - [ ] 所有驗收條件已逐項自我檢查並打勾
   - [ ] 所有測試 100% 通過
   - [ ] 已標記 Ticket 狀態為「Review 中」

**使用時機**：
- Ticket 領取時填寫領取確認
- 每個 Phase 完成後填寫交接確認
- 提交 Review 前填寫提交確認

#### 驗收暫停點設計

**基於《清單革命》暫停點原則**：

> "在製作清單的時候，你必須做一些重要決定。首先，你得確定使用清單的暫停點。"

**5 個關鍵暫停點**：

| 暫停點 | 觸發條件 | 檢查人 | 通過標準 |
|--------|---------|--------|---------|
| **領取暫停點** | 開發者領取 Ticket | 開發者自我檢查 | Ticket 領取確認清單全部打勾 |
| **Phase 2 暫停點** | sage 標記 Phase 2 完成 | rosemary-project-manager | Phase 2 驗收條件全部打勾 |
| **Phase 3 暫停點** | parsley 標記 Phase 3 完成 | 開發者自我檢查 | 所有步驟執行追蹤打勾 + 所有測試通過 |
| **Review 提交暫停點** | 開發者認為已完成 | 開發者自我檢查 | Review 提交確認清單全部打勾 |
| **Review 完成暫停點** | Reviewer 完成檢查 | rosemary-project-manager | 所有驗收條件打勾 + Review 通過 |

**暫停點使用規則**：
- ⏸️ 執行代理人完成階段後必須主動暫停
- 📋 主線程在暫停點執行驗收檢查
- ✅ 通過檢查後才能繼續下一階段
- ❌ 未通過檢查則返回修正

#### 清單使用模式選擇

**基於《清單革命》兩種清單使用模式**：

> "你必須決定採用操作確認模式，或是大家一起一步步照著清單來做。"

**模式 1：操作確認模式（DO-CONFIRM）**
- **適用場景**：執行過類似 Ticket 3 次以上、Ticket 步驟簡單明確
- **使用方式**：先自主完成工作，然後暫停，對照清單逐項確認
- **優點**：提高效率，避免過度流程化
- **風險**：可能遺漏步驟，需依賴代理人經驗

**模式 2：步驟執行模式（READ-DO）**
- **適用場景**：首次執行此類 Ticket、Ticket 步驟複雜或有多個依賴
- **使用方式**：邊看清單邊執行，逐項完成並打勾
- **優點**：確保不遺漏步驟，降低出錯風險
- **風險**：可能過度依賴清單，降低效率

**模式選擇標準**：

| 情況 | 建議模式 | 理由 |
|-----|---------|------|
| 新手代理人（首次執行任務） | READ-DO | 確保不遺漏步驟 |
| 熟練代理人（執行過 3 次以上） | DO-CONFIRM | 提高效率，清單作為最後檢查 |
| 複雜/高風險任務 | READ-DO | 降低出錯風險 |
| 簡單/重複任務 | DO-CONFIRM | 避免過度流程化 |

#### 實務應用指引

**使用流程**：

1. **Ticket 建立時**：
   - 使用 `.claude/templates/ticket-log-template.md` 建立 Ticket 日誌
   - 填寫 5 個核心欄位（背景、目標、步驟、驗收條件、參考文件）
   - 確認驗收條件符合 SMART 原則

2. **Ticket 執行時**：
   - 更新 TDD 階段狀態表（每個 Phase 完成後更新）
   - 填寫協作檢查點（領取、交接、提交）
   - 在暫停點執行檢查（5 個暫停點）

3. **Ticket 完成時**：
   - 更新總體狀態判定為「已完成待提交」
   - 確認所有驗收條件已打勾
   - 記錄完成時間和總工時

**檢查清單**：

- [ ] Ticket 日誌包含「TDD 階段狀態」區塊
- [ ] 所有驗收條件符合 SMART 原則
- [ ] 協作檢查點已設定並使用
- [ ] 暫停點已明確標記
- [ ] 清單使用模式已選擇並記錄

**常見錯誤和解決方案**：

| 錯誤 | 後果 | 解決方案 |
|-----|------|---------|
| **狀態標記不一致** | 進度誤判 | 使用標準狀態表格，每個 Phase 完成後立即更新 |
| **驗收條件模糊** | 無法客觀判斷完成 | 使用 SMART 原則，每個條件可測量可驗證 |
| **協作資訊遺漏** | Phase 交接問題 | 使用協作檢查點，確保關鍵資訊完整傳遞 |
| **跳過暫停點檢查** | 遺漏關鍵步驟 | 強制執行暫停點，未通過檢查不得繼續 |

**參考範例**：

- 標準 Ticket 工作日誌範例：`docs/work-logs/v0.12.I-ticket-001.md`（包含完整的標準化格式）
- 主版本工作日誌範例：`docs/work-logs/v0.12.I.0-work-log-standardization-main.md`（展示多 Ticket 管理）

#### 代理人協作機制與工作日誌管理

**代理人職責分工**：

| 代理人 | TDD Phase | 工作日誌職責 | 協作重點 |
|--------|-----------|-------------|---------|
| **rosemary-project-manager** | 主線程管理 | 建立主版本日誌、Ticket 索引管理 | 分派任務、驗收暫停點檢查 |
| **lavender-interface-designer** | Phase 1 | 記錄設計產出到工作日誌 | 設計文件、介面定義、架構圖 |
| **sage-test-architect** | Phase 2 | 記錄測試設計到工作日誌 | 測試案例、覆蓋範圍、測試策略 |
| **pepper-test-implementer** | Phase 3a | 記錄實作策略到工作日誌 | 虛擬碼、流程圖、實作指引 |
| **parsley-flutter-developer** | Phase 3b | 記錄程式碼實作到工作日誌 | 實作邏輯、測試結果、問題解決 |
| **cinnamon-refactor-owl** | Phase 4 | 記錄重構評估和執行到工作日誌 | 重構建議、執行記錄、品質改善 |

**工作日誌填寫時機**：

1. **主版本日誌填寫時機**（rosemary 負責）：
   - **任務啟動時**：建立 `vX.Y.Z-main.md`，填寫任務概述、目標、背景
   - **Ticket 拆分時**：建立 Ticket 索引表，記錄所有 Ticket 編號和狀態
   - **Phase 完成時**：更新 TDD 階段狀態、驗收條件打勾、執行暫停點檢查
   - **任務完成時**：更新總體狀態為「已完成待提交」，確認所有 Ticket 完成

2. **Ticket 日誌填寫時機**（執行代理人負責）：
   - **Ticket 建立時**：建立 `vX.Y.Z-ticket-NNN.md`，填寫 5 個核心欄位
   - **Ticket 領取時**：填寫領取確認清單，標記狀態為「進行中」
   - **Phase 執行中**：即時記錄執行過程、遇到問題、解決方案
   - **Phase 完成時**：更新 TDD 階段狀態、填寫 Phase 交接確認清單
   - **提交 Review 前**：填寫 Review 提交確認清單，標記狀態為「Review 中」
   - **Review 完成後**：記錄 Review 結果、修正記錄、最終狀態

**代理人協作流程與工作日誌同步**：

```text
rosemary 建立主版本日誌
    ↓ 填寫任務概述、目標
lavender 領取 Phase 1 任務
    ↓ 在主版本日誌記錄設計產出
sage 領取 Phase 2 任務
    ↓ 閱讀 Phase 1 產出，在主版本日誌記錄測試設計
pepper 領取 Phase 3a 任務
    ↓ 閱讀 Phase 2 產出，在主版本日誌記錄實作策略
parsley 領取 Phase 3b 任務
    ↓ 閱讀 Phase 3a 產出，在主版本日誌記錄程式碼實作
cinnamon 領取 Phase 4 任務
    ↓ 閱讀 Phase 3 產出，在主版本日誌記錄重構評估
rosemary 驗收完成
    ↓ 更新主版本日誌總體狀態、提交 git commit
```

**協作檢查點與工作日誌檢查**：

| 檢查點 | 檢查人 | 檢查內容（基於工作日誌） |
|--------|--------|----------------------|
| **Phase 交接檢查** | 下一階段代理人 | 確認前一階段產出已記錄、內容完整可理解 |
| **暫停點檢查** | rosemary-project-manager | 確認驗收條件打勾、協作清單完成、狀態正確 |
| **Review 檢查** | rosemary-project-manager | 確認所有驗收條件打勾、測試通過、文件同步 |

**工作日誌自我檢查清單**：

執行代理人在每個 Phase 完成後，必須自我檢查以下項目：

- [ ] **執行記錄完整**：記錄了執行時間、執行人、關鍵產出
- [ ] **問題已記錄**：遇到的問題和解決方案已記錄
- [ ] **產出可交接**：下一階段代理人可從記錄理解產出內容
- [ ] **狀態已更新**：TDD 階段狀態表已更新為「完成」
- [ ] **驗收條件打勾**：該 Phase 的驗收條件已逐項檢查並打勾
- [ ] **協作清單完成**：Phase 交接溝通確認清單已填寫

**常見協作問題與解決方案**：

| 問題 | 原因 | 解決方案（基於工作日誌） |
|-----|------|----------------------|
| **Phase 交接不清楚** | 前一階段產出記錄不完整 | 強制填寫執行記錄，包含產出檔案、關鍵決策、使用方式 |
| **重複實作** | 代理人未閱讀工作日誌 | Ticket 領取確認清單強制要求閱讀參考文件和前一階段產出 |
| **驗收標準不一致** | 驗收條件模糊 | 使用 SMART 原則設計驗收條件，每個條件可客觀驗證 |
| **暫停點被跳過** | 代理人未意識到需要檢查 | 工作日誌明確標記 5 個暫停點，rosemary 強制執行檢查 |

---

## 第四章：Ticket 驗收標準（SMART 原則）

### 4.1 SMART 原則概述

驗收條件必須符合 SMART 原則，確保條件可客觀驗證、無歧義、可達成。

**SMART 定義**：

- **S** - Specific（具體）：條件描述具體明確，無模糊用語
- **M** - Measurable（可測量）：條件可客觀測量和驗證
- **A** - Achievable（可達成）：條件在合理範圍內可達成
- **R** - Relevant（相關）：條件與 Ticket 目標直接相關
- **T** - Time-bound（有明確完成標準）：條件有明確的完成定義

### 4.2 S - Specific（具體）

**原則**：條件描述具體明確，避免模糊用語和主觀描述。

**不良範例 ❌ 及改進 ✅**：

```markdown
❌ 功能運作正常
   問題：什麼是「正常」？如何判斷？

✅ 呼叫 `getBookByIsbn('978-0134685991')` 回傳正確的 Book 物件，
   包含 title、author、isbn、publishDate 四個欄位

❌ 程式碼品質良好
   問題：什麼是「良好」？標準是什麼？

✅ `dart analyze` 0 錯誤，0 警告，程式碼符合專案規範
   （package 導入格式、命名規範、註解完整性）

❌ UI 顯示正確
   問題：什麼是「正確」？包含哪些元素？

✅ 書籍列表頁顯示所有書籍，每本書包含封面圖、書名、作者、
   ISBN 四個元素，點擊後進入詳情頁
```

**具體化技巧**：

1. **使用數字和具體值**：
   - 不用：「很多」、「足夠」、「良好」
   - 使用：「≥ 10 本」、「100%」、「0 錯誤」

2. **明確指定對象**：
   - 不用：「相關檔案」、「一些測試」
   - 使用：「`lib/domains/library/entities/book.dart`」、「5 個單元測試」

3. **描述具體行為**：
   - 不用：「功能正常」
   - 使用：「呼叫方法 X，回傳結果 Y，狀態變為 Z」

### 4.3 M - Measurable（可測量）

**原則**：條件可客觀測量和驗證，使用可量化的標準。

**不良範例 ❌ 及改進 ✅**：

```markdown
❌ 效能良好
   問題：無法測量「良好」

✅ API 響應時間 ≤ 200ms（95th percentile），
   資料庫查詢時間 ≤ 50ms

❌ 測試覆蓋率高
   問題：「高」無明確標準

✅ 測試覆蓋率 ≥ 80%，所有 public 方法都有單元測試

❌ 使用者體驗佳
   問題：無法客觀測量「佳」

✅ 書籍搜尋功能回應時間 ≤ 1 秒，
   搜尋結果顯示相關度排序，
   每頁顯示 20 筆結果
```

**可測量化技巧**：

1. **使用百分比**：
   - 測試通過率 100%
   - 測試覆蓋率 ≥ 80%
   - 錯誤率 ≤ 1%

2. **使用數量**：
   - 0 錯誤
   - ≥ 5 個測試案例
   - ≤ 10 個檔案

3. **使用時間**：
   - ≤ 200ms 響應時間
   - ≤ 1 秒載入時間
   - 每日執行 1 次

4. **使用工具驗證**：
   - `dart analyze` 檢查
   - `flutter test` 執行
   - `dart run coverage` 測量

### 4.4 A - Achievable（可達成）

**原則**：條件在合理範圍內可達成，避免範圍過大或不切實際。

**不良範例 ❌ 及改進 ✅**：

```markdown
❌ 整合所有第三方 API
   問題：範圍太大，無法在單一 Ticket 完成

✅ 整合 Google Books API 的書籍搜尋功能，
   支援 ISBN 查詢和關鍵字搜尋

❌ 實作完整的使用者系統
   問題：範圍太大，應拆分為多個 Ticket

✅ 實作使用者註冊功能，包含 email 驗證和密碼加密

❌ 優化所有效能問題
   問題：範圍不明確，無法判斷完成

✅ 優化書籍列表載入速度，從 2 秒降至 ≤ 500ms，
   使用分頁機制每次載入 20 筆
```

**可達成化技巧**：

1. **限制範圍**：
   - 不用：「所有」、「完整」、「全部」
   - 使用：「書籍搜尋」、「使用者註冊」、「分頁載入」

2. **拆分大任務**：
   - 大任務：實作使用者系統
   - 拆分：註冊、登入、個人資料、密碼重設 4 個 Ticket

3. **設定合理標準**：
   - 不用：「100% 測試覆蓋率」（不切實際）
   - 使用：「≥ 80% 測試覆蓋率」（合理且可達成）

### 4.5 R - Relevant（相關）

**原則**：條件與 Ticket 目標直接相關，避免無關或過度延伸的條件。

**不良範例 ❌ 及改進 ✅**：

```markdown
Ticket 目標：實作 SQLiteBookRepository

❌ UI 顏色符合設計規範
   問題：與 Repository Ticket 無關

✅ SQLiteBookRepository 類別實作完成，
   符合 IBookRepository 介面

❌ 使用者手冊已更新
   問題：與 Repository 實作無直接關係

✅ Repository 方法註解完整，說明參數、回傳值、異常處理

❌ 所有 Widget 測試通過
   問題：Ticket 是 Repository 層，不涉及 Widget

✅ Repository 單元測試通過，覆蓋所有 CRUD 方法
```

**相關性檢查技巧**：

1. **回歸 Ticket 目標**：
   - 每個驗收條件都應直接支持 Ticket 目標
   - 問自己：「這個條件是否必要？」

2. **遵循分層原則**：
   - Repository Ticket → Repository 層驗收條件
   - UI Ticket → UI 層驗收條件
   - 不跨層設定條件

3. **避免範圍蔓延**：
   - 發現無關條件 → 移除或建立新 Ticket
   - 保持 Ticket 單一職責

### 4.6 T - Time-bound（有明確完成標準）

**原則**：條件有明確的完成定義，知道什麼時候算「完成」。

**不良範例 ❌ 及改進 ✅**：

```markdown
❌ 持續優化效能
   問題：無明確完成標準，可無限優化

✅ API 響應時間從 500ms 降至 ≤ 200ms，達標即完成

❌ 未來會完成文檔
   問題：「未來」無明確時間

✅ Ticket 完成時，API 文檔同步更新，包含所有 public 方法說明

❌ 盡量提高測試覆蓋率
   問題：「盡量」無明確標準

✅ 測試覆蓋率 ≥ 80%，達標即完成
```

**明確完成標準技巧**：

1. **使用「符合即完成」模式**：
   - `dart analyze` 0 錯誤 → 符合即完成
   - 測試覆蓋率 ≥ 80% → 符合即完成

2. **避免開放式描述**：
   - 不用：「持續」、「盡量」、「未來」
   - 使用：「達標」、「符合」、「完成」

3. **設定具體閾值**：
   - 不用：「提高覆蓋率」
   - 使用：「覆蓋率從 60% 提高到 ≥ 80%」

### 4.7 SMART 驗收條件範例

#### 範例 1：Repository 實作 Ticket

**Ticket 目標**：實作 SQLiteBookRepository 類別

**SMART 驗收條件**：

```markdown
### 驗收條件

- [ ] **S + M**: `SQLiteBookRepository` 類別實作完成，
      繼承 `IBookRepository` 介面，包含 4 個 CRUD 方法
      （create, getById, update, delete）

- [ ] **S + M + A**: `create()` 方法正確插入書籍資料到 SQLite，
      回傳新增的 Book 物件，包含自動生成的 ID

- [ ] **S + M**: `getById()` 方法根據 ID 查詢書籍，
      找到時回傳 Book 物件，找不到時拋出 `BookNotFoundException`

- [ ] **S + M + T**: 單元測試覆蓋所有 CRUD 方法，
      測試通過率 100%，測試覆蓋率 ≥ 80%

- [ ] **M + T**: `dart analyze` 0 錯誤，0 警告

- [ ] **R + T**: 程式碼符合專案規範：
      package 導入格式、命名規範、註解完整性
```

#### 範例 2：UI 功能 Ticket

**Ticket 目標**：實作書籍列表頁

**SMART 驗收條件**：

```markdown
### 驗收條件

- [ ] **S + M**: 書籍列表頁顯示所有書籍，每本書包含：
      封面圖（100x150px）、書名、作者、ISBN

- [ ] **S + T**: 點擊書籍進入詳情頁，
      顯示完整資訊（書名、作者、ISBN、出版日期、簡介）

- [ ] **S + M + T**: 列表支援下拉刷新，
      刷新時間 ≤ 1 秒，顯示 loading 指示器

- [ ] **M + T**: Widget 測試覆蓋列表頁和詳情頁，
      測試通過率 100%

- [ ] **S + R**: UI 符合設計規範：
      字體大小、顏色、間距符合 `docs/ui_design_specification.md`

- [ ] **M + T**: `flutter analyze` 0 錯誤，0 警告
```

---

## 第五章：Ticket 關閉條件與檢查

### 5.1 強制關閉條件（5 項）

Ticket 必須滿足以下 5 項強制條件才能關閉，缺一不可。

#### 條件 1：所有驗收條件打勾完成

**要求**：

- Ticket 的所有驗收條件 checkbox 都已打勾 ✅
- 每個條件都已客觀驗證
- 無遺漏或跳過的條件

**檢查方式**：

```markdown
### 驗收條件

- [x] 條件 1 ✅
- [x] 條件 2 ✅
- [x] 條件 3 ✅
- [x] 條件 4 ✅
- [x] 條件 5 ✅

✅ 所有驗收條件已完成
```

#### 條件 2：Review 通過

**要求**：

- Reviewer 檢查所有驗收條件
- Reviewer 確認驗收通過
- Review 意見已全部處理

**檢查方式**：

```markdown
### Review 結果

**Reviewer**: @reviewer_name
**Review 時間**: 2025-10-11 18:00
**結果**: 通過 ✅

**檢查項目**：
- [x] 驗收條件檢查 ✅
- [x] 程式碼品質檢查 ✅
- [x] 測試檢查 ✅
- [x] 文檔檢查 ✅

**結論**: Ticket 符合所有標準，可關閉
```

#### 條件 3：相關測試 100% 通過

**要求**：

- 所有相關測試 100% 通過
- 包含 Unit tests、Integration tests、Widget tests（如適用）
- 無跳過或忽略的測試

**檢查方式**：

```bash
# 執行測試
$ flutter test

# 輸出
00:05 +50: All tests passed!

✅ 50/50 tests passed (100%)
```

#### 條件 4：dart analyze 0 錯誤

**要求**：

- `dart analyze` 執行結果 0 錯誤
- 建議 0 警告（警告應盡量修正）
- 無遺留的 linter 問題

**檢查方式**：

```bash
# 執行 analyze
$ dart analyze

# 輸出
Analyzing book_overview_app...
No issues found!

✅ 0 errors, 0 warnings
```

#### 條件 5：工作日誌已更新

**要求**：

- 在主版本工作日誌中記錄 Ticket 完成
- 更新 Ticket 索引表
- 記錄完成時間和實際工時

**檢查方式**：

```markdown
### Ticket 索引（vX.Y.0-main.md）

| Ticket | 標題 | 狀態 | 完成時間 | 工時 |
|--------|------|------|---------|------|
| #1 | 定義 IBookRepository 介面 | 已完成 ✅ | 2025-10-10 | 2h |
| #2 | 撰寫 BookRepository 測試 | 已完成 ✅ | 2025-10-10 | 3h |
| #3 | 實作 SQLiteBookRepository | 已完成 ✅ | 2025-10-11 | 6.5h |

✅ Ticket #3 已記錄到工作日誌
```

### 5.2 建議關閉條件（3 項）

以下 3 項建議條件雖非強制，但建議盡量滿足以確保長期程式碼品質。

#### 建議 1：程式碼符合專案規範

**要求**：

- 程式碼風格符合專案規範
- 命名清晰明確
- 檔案組織結構正確
- 註解完整且正確

**檢查方式**：

使用專案的 Code Review Checklist：

```markdown
### 程式碼規範檢查

- [x] Package 導入使用 `package:` 格式 ✅
- [x] 命名遵循 Dart 規範（類別 PascalCase，方法 camelCase）✅
- [x] 函式長度 ≤ 50 行 ✅
- [x] 註解完整（public API 都有文檔註解）✅
- [x] 錯誤處理使用 AppException 系統 ✅

✅ 程式碼符合專案規範
```

#### 建議 2：無技術債務產生

**要求**：

- 無 TODO 或 FIXME 註解遺留
- 無暫時性解決方案（workaround）
- 無已知問題未處理

**檢查方式**：

```bash
# 搜尋 TODO 和 FIXME
$ grep -r "TODO\|FIXME" lib/

# 輸出（理想狀態）
✅ No TODOs or FIXMEs found
```

**如有技術債務**：

```markdown
### 技術債務記錄

發現 2 個 TODO：

1. **TODO**: 優化 getBookById 查詢效能
   - 位置：`lib/infrastructure/database/repositories/sqlite_book_repository.dart:45`
   - 影響：查詢速度可能較慢
   - 處理：建立 Ticket #10 優化

2. **TODO**: 補充錯誤處理文檔
   - 位置：`lib/core/errors/app_exception.dart:120`
   - 影響：文檔不完整
   - 處理：建立 Ticket #11 補充

✅ 所有技術債務已建立追蹤 Ticket
```

#### 建議 3：文檔同步更新

**要求**：

- API 文檔同步更新（如修改 public API）
- 使用者文檔同步更新（如新增功能）
- 設計文檔同步更新（如架構變更）

**檢查方式**：

```markdown
### 文檔更新檢查

- [x] API 文檔已更新：
      `docs/api/repository_api.md` 新增 SQLiteBookRepository 說明 ✅

- [x] 架構文檔已更新：
      `docs/domain-transformation-layer-design.md` 新增實作說明 ✅

- [ ] 使用者文檔：N/A（本 Ticket 不涉及使用者功能）

✅ 相關文檔已同步更新
```

### 5.3 關閉檢查清單

在關閉 Ticket 前，使用以下完整檢查清單確保所有條件滿足：

#### 強制條件檢查（5 項）

```markdown
### Ticket 關閉檢查清單

#### 強制條件（必須全部滿足）

- [ ] **條件 1**: 所有驗收條件打勾完成
      - 檢查方式：逐項檢查 Ticket 驗收條件 checkbox
      - 狀態：___/5 完成

- [ ] **條件 2**: Review 通過
      - Reviewer：__________
      - Review 時間：__________
      - 狀態：通過 ✅ / 未通過 ❌

- [ ] **條件 3**: 相關測試 100% 通過
      - 測試結果：___/___通過
      - 狀態：100% ✅ / 失敗 ❌

- [ ] **條件 4**: dart analyze 0 錯誤
      - analyze 結果：___ 錯誤，___ 警告
      - 狀態：0 錯誤 ✅ / 有錯誤 ❌

- [ ] **條件 5**: 工作日誌已更新
      - 工作日誌：vX.Y.0-main.md
      - 更新時間：__________
      - 狀態：已更新 ✅ / 未更新 ❌

✅ 所有強制條件已滿足，可關閉 Ticket
❌ 尚有 ___ 項強制條件未滿足，不可關閉
```

#### 建議條件檢查（3 項）

```markdown
#### 建議條件（建議滿足）

- [ ] **建議 1**: 程式碼符合專案規範
      - 檢查項目：導入格式、命名規範、註解完整性
      - 狀態：符合 ✅ / 部分符合 ⚠️ / 不符合 ❌

- [ ] **建議 2**: 無技術債務產生
      - 檢查方式：搜尋 TODO / FIXME
      - 結果：___ 個技術債務
      - 處理：已建立追蹤 Ticket ✅ / 未處理 ❌

- [ ] **建議 3**: 文檔同步更新
      - 需更新文檔：API 文檔、使用者文檔、設計文檔
      - 狀態：已更新 ✅ / 部分更新 ⚠️ / 未更新 ❌

💡 建議條件滿足 ___/3 項
```

---

## 第六章：生命週期管理最佳實踐

### 6.1 完整案例：書籍查詢功能 Ticket 生命週期

#### 案例背景

專案需要實作書籍查詢功能，從 Ticket 建立到關閉的完整流程示範。

#### Ticket 建立（狀態：待執行）

```markdown
## Ticket #5: 實作書籍查詢功能

### 1. 背景

根據需求規格 `docs/app-requirements-spec.md` 第 4.1 節「書籍查詢」，
使用者需要能夠根據 ISBN、書名、作者查詢書籍。

當前 SQLiteBookRepository 已實作 `getById()` 方法（Ticket #3），
但僅支援 ID 查詢。本 Ticket 新增 `searchBooks()` 方法，
支援多條件組合查詢。

### 2. 目標

實作 `searchBooks()` 方法，支援 ISBN、書名、作者三種查詢條件，
支援模糊搜尋和條件組合，回傳符合條件的書籍列表。

### 3. 步驟

1. 在 `IBookRepository` 介面新增 `searchBooks()` 方法定義
2. 在 `SQLiteBookRepository` 實作 `searchBooks()` 方法
3. 實作 SQL WHERE 子句生成邏輯，支援條件組合
4. 實作模糊搜尋（使用 LIKE 子句）
5. 撰寫單元測試，覆蓋各種查詢場景
6. 執行測試確保 100% 通過

### 4. 驗收條件

- [ ] `searchBooks()` 方法實作完成，支援 3 種查詢條件（ISBN、書名、作者）
- [ ] 支援模糊搜尋，如搜尋「Clean」可找到書名包含「Clean Code」的書籍
- [ ] 支援條件組合，如同時指定作者和書名
- [ ] 空條件時回傳所有書籍，無結果時回傳空列表
- [ ] 單元測試覆蓋 6 種場景（單條件、組合條件、模糊搜尋、空條件、無結果、邊界條件）
- [ ] `dart analyze` 0 錯誤，程式碼符合專案規範

### 5. 參考文件

- 需求規格：`docs/app-requirements-spec.md` 第 4.1 節
- 介面定義：`lib/domains/library/interfaces/i_book_repository.dart`
- 現有實作：`lib/infrastructure/database/repositories/sqlite_book_repository.dart`

### 6. 依賴 Ticket

- Ticket #3: 實作 SQLiteBookRepository（已完成 ✅）
```

**狀態**：待執行（Pending）

---

#### 領取 Ticket（狀態：進行中）

**時間**：2025-10-11 10:00

**執行動作**：

```markdown
### Ticket 領取記錄

**開發者**：@developer_name
**領取時間**：2025-10-11 10:00
**預估工時**：6 小時

**依賴檢查**：
- [x] Ticket #3 已完成 ✅

**理解確認**：
- [x] 閱讀背景和目標 ✅
- [x] 理解 6 個執行步驟 ✅
- [x] 理解 6 個驗收條件 ✅
- [x] 閱讀參考文件 ✅

**狀態變更**：待執行 → 進行中
```

**狀態**：進行中（In Progress）

---

#### 執行步驟（狀態：進行中）

**時間**：2025-10-11 10:30 - 15:30

**執行日誌**：

```markdown
### 執行日誌

**2025-10-11 10:30** - 步驟 1 完成 ✅
- 在 `IBookRepository` 新增 `searchBooks()` 方法定義
- 定義 `SearchCriteria` 類別封裝查詢條件

**2025-10-11 11:00** - 步驟 2-3 完成 ✅
- 實作 `searchBooks()` 方法
- 實作 `_buildWhereClause()` 私有方法生成 SQL WHERE 子句

**2025-10-11 12:00** - 遇到問題 ⚠️
- 問題：模糊搜尋無法處理特殊字元（如 % 和 _）
- 嘗試方案 1：直接使用 LIKE 子句 → 失敗（特殊字元導致錯誤結果）
- 嘗試方案 2：使用 escape 機制跳脫特殊字元 → 成功 ✅
- 解決方案：實作 `_escapeSpecialChars()` 方法

**2025-10-11 13:00** - 步驟 4-5 完成 ✅
- 模糊搜尋實作完成
- 撰寫 6 個單元測試案例

**2025-10-11 14:00** - 步驟 6 完成 ✅
- 執行測試，初次結果：5/6 通過
- 修正邊界條件測試失敗問題
- 重新執行測試：6/6 通過 ✅

**2025-10-11 15:30** - 自我檢查完成 ✅
- 所有驗收條件滿足
- dart analyze 0 錯誤
- 準備提交 Review
```

**狀態**：進行中（In Progress） → 準備進入 Review 中

---

#### 自我檢查（狀態：進行中）

**時間**：2025-10-11 15:30

**自我檢查清單**：

```markdown
### 自我檢查清單

#### 驗收條件檢查
- [x] 條件 1：`searchBooks()` 方法支援 3 種查詢條件 ✅
- [x] 條件 2：支援模糊搜尋 ✅
- [x] 條件 3：支援條件組合 ✅
- [x] 條件 4：空條件回傳所有書籍，無結果回傳空列表 ✅
- [x] 條件 5：單元測試覆蓋 6 種場景，100% 通過 ✅
- [x] 條件 6：dart analyze 0 錯誤 ✅

#### 測試檢查
- [x] 單元測試 6/6 通過 ✅
- [x] 測試覆蓋率 85% ✅

#### 程式碼品質檢查
- [x] 程式碼風格符合規範 ✅
- [x] Package 導入使用 `package:` 格式 ✅
- [x] 命名清晰明確 ✅
- [x] 註解完整 ✅

#### 文檔檢查
- [x] `IBookRepository` 介面文檔已更新 ✅

✅ 所有檢查通過，可提交 Review
```

---

#### 提交 Review（狀態：Review 中）

**時間**：2025-10-11 15:45

**Review 請求**：

```markdown
@Reviewer

Ticket #5 已完成開發，請 Review。

**完成摘要**：
- 實作 `searchBooks()` 方法，支援 ISBN、書名、作者三種查詢條件
- 支援模糊搜尋和條件組合
- 處理特殊字元跳脫問題
- 撰寫 6 個單元測試，覆蓋各種場景

**驗收條件**：
- [x] 所有 6 個驗收條件已滿足（見 Ticket）

**自我檢查**：
- [x] 驗收條件檢查通過
- [x] 測試檢查通過（6/6 tests, 85% coverage）
- [x] 程式碼品質檢查通過
- [x] 文檔檢查通過

**實際工時**：5.5 小時（預估 6 小時）

**特別說明**：
- 實作過程中發現模糊搜尋特殊字元問題，已解決並記錄到執行日誌
```

**狀態變更**：進行中 → Review 中

---

#### Review 檢查（狀態：Review 中）

**時間**：2025-10-11 16:30

**Review 結果**：

```markdown
### Review 結果

**Reviewer**: @reviewer_name
**Review 時間**: 2025-10-11 16:30
**結果**: 通過 ✅

**檢查項目**：

#### 驗收條件檢查
- [x] 所有 6 個驗收條件滿足 ✅

#### 程式碼品質檢查
- [x] 程式碼風格符合規範 ✅
- [x] 命名清晰明確 ✅
- [x] 註解完整 ✅
- [x] 錯誤處理正確 ✅

#### 測試檢查
- [x] 單元測試 6/6 通過 ✅
- [x] 測試覆蓋主要場景 ✅
- [x] 測試覆蓋率 85% ✅

#### 文檔檢查
- [x] 介面文檔已更新 ✅

**Review 意見**：

✅ **通過**: 實作品質優良，測試完整，可關閉 Ticket。

**亮點**：
- 特殊字元處理考慮周全
- 測試案例覆蓋全面
- 執行日誌記錄詳細

**結論**: Ticket 符合所有標準，可關閉 ✅
```

**狀態變更**：Review 中 → 已完成

---

#### Ticket 關閉（狀態：已完成）

**時間**：2025-10-11 16:45

**關閉檢查清單**：

```markdown
### Ticket 關閉檢查清單

#### 強制條件
- [x] 條件 1：所有驗收條件打勾完成 ✅（6/6）
- [x] 條件 2：Review 通過 ✅
- [x] 條件 3：相關測試 100% 通過 ✅（6/6 tests）
- [x] 條件 4：dart analyze 0 錯誤 ✅
- [x] 條件 5：工作日誌已更新 ✅

#### 建議條件
- [x] 建議 1：程式碼符合專案規範 ✅
- [x] 建議 2：無技術債務產生 ✅
- [x] 建議 3：文檔同步更新 ✅

✅ 所有條件已滿足，Ticket 正式關閉
```

**完成記錄**：

```markdown
### Ticket 完成記錄

**完成時間**：2025-10-11 16:45
**總工時**：6.25 小時（開始 10:00 → 完成 16:45，扣除午休 0.5h）
**預估工時**：6 小時
**偏差**：+0.25 小時（+4%）

**完成摘要**：
- 實作 `searchBooks()` 方法，支援多條件組合查詢
- 處理特殊字元跳脫問題
- 撰寫 6 個單元測試，覆蓋率 85%
- Review 通過，無需修正

**經驗總結**：
- 模糊搜尋需考慮特殊字元處理
- 測試案例應包含邊界條件
- 執行日誌詳細記錄有助於 Review

**後續 Ticket**：
- Ticket #6: 整合 searchBooks() 到 UI 層（待執行）
```

**工作日誌更新**：

```markdown
### Ticket 索引（vX.Y.0-main.md）

| Ticket | 標題 | 狀態 | 完成時間 | 工時 |
|--------|------|------|---------|------|
| #3 | 實作 SQLiteBookRepository | 已完成 ✅ | 2025-10-10 | 6.5h |
| #5 | 實作書籍查詢功能 | 已完成 ✅ | 2025-10-11 | 6.25h |

✅ Ticket #5 已記錄到工作日誌
```

**最終狀態**：已完成（Completed）

---

### 6.2 生命週期管理常見問題

#### 問題 1：Ticket 長時間停留在「進行中」

**症狀**：
- Ticket 開始執行超過 2 天仍未完成
- 進度更新停滯
- 開發者無回應

**原因分析**：
- Ticket 範圍過大，超出合理工作量
- 遇到技術問題無法解決
- 開發者被其他緊急任務打斷

**解決方案**：

1. **重新評估 Ticket 範圍**：
   - 檢查 Ticket 步驟和驗收條件
   - 評估是否需要拆分為更小的 Ticket
   - 與開發者溝通，了解實際困難

2. **提供技術支援**：
   - 如遇到技術問題，組織技術討論
   - 尋找有經驗的團隊成員協助
   - 考慮建立 POC（Proof of Concept）驗證可行性

3. **調整優先級**：
   - 如有更緊急任務，暫停當前 Ticket
   - 標記 Ticket 為「待執行」並記錄原因
   - 完成緊急任務後恢復執行

#### 問題 2：Review 反覆未通過

**症狀**：
- Ticket 多次提交 Review 仍未通過
- Review 意見反覆出現相同問題
- 開發者和 Reviewer 產生摩擦

**原因分析**：
- 驗收條件定義不清，理解有歧義
- 開發者未充分自我檢查
- Reviewer 標準過嚴或不一致

**解決方案**：

1. **澄清驗收條件**：
   - 開發者和 Reviewer 共同檢視驗收條件
   - 確保理解一致，無歧義
   - 必要時更新驗收條件定義

2. **加強自我檢查**：
   - 開發者使用自我檢查清單
   - 提交 Review 前模擬 Reviewer 視角檢查
   - 記錄自我檢查結果

3. **Review 標準透明化**：
   - 制定 Code Review Checklist
   - Reviewer 說明具體不通過原因和改進方向
   - 避免主觀評價，使用客觀標準

#### 問題 3：Ticket 關閉後發現遺漏

**症狀**：
- Ticket 關閉後發現功能不完整
- 測試未覆蓋某些場景
- 文檔未同步更新

**原因分析**：
- 驗收條件不完整，未覆蓋所有面向
- Review 檢查不夠仔細
- 關閉條件檢查清單未嚴格執行

**解決方案**：

1. **完善驗收條件**：
   - 建立 Ticket 時充分思考驗收條件
   - 涵蓋功能、測試、品質、文檔四個維度
   - 與團隊討論，避免遺漏

2. **嚴格執行關閉檢查**：
   - 使用關閉檢查清單，逐項確認
   - 不跳過任何檢查項目
   - 發現遺漏立即補充

3. **建立修正 Ticket**：
   - 發現遺漏後立即建立修正 Ticket
   - 標註為「Bug」或「遺漏」
   - 高優先級處理

#### 問題 4：依賴 Ticket 阻塞執行

**症狀**：
- 多個 Ticket 等待依賴完成
- 開發進度停滯
- 團隊負載不平衡

**原因分析**：
- 依賴關係規劃不當，產生瓶頸
- 依賴 Ticket 優先級不高
- 未識別可並行的機會

**解決方案**：

1. **重新評估依賴關係**：
   - 檢查依賴是否為強依賴
   - 評估是否可轉為弱依賴（可並行）
   - 考慮調整實作順序

2. **提高依賴 Ticket 優先級**：
   - 將阻塞性依賴 Ticket 標為高優先級
   - 集中資源優先完成
   - 解除阻塞後再並行開發

3. **尋找並行機會**：
   - 分析 Ticket 間的實際依賴
   - 識別可並行開發的部分
   - 調整 Ticket 設計，減少依賴

---

## 附錄 A：術語表

| 術語 | 英文 | 定義 |
|------|------|------|
| **Ticket** | Ticket | 開發任務的承載單位，包含目標、步驟、驗收條件等完整資訊 |
| **待執行** | Pending | Ticket 狀態之一，表示已準備就緒等待開發者領取執行 |
| **進行中** | In Progress | Ticket 狀態之一，表示開發者正在積極執行 |
| **Review 中** | In Review | Ticket 狀態之一，表示已完成執行等待 Review 驗收 |
| **已完成** | Completed | Ticket 狀態之一，表示通過 Review 驗收並正式關閉 |
| **驗收條件** | Acceptance Criteria | 客觀可驗證的條件，用於判斷 Ticket 是否完成 |
| **SMART 原則** | SMART Principle | 驗收條件制定原則：Specific、Measurable、Achievable、Relevant、Time-bound |
| **強依賴** | Blocking Dependency | 必須先完成的依賴 Ticket，未完成前無法開始執行 |
| **弱依賴** | Parallel Dependency | 相關但可並行的依賴 Ticket，可同時開發後整合 |
| **WIP 限制** | Work In Progress Limit | 限制同時進行中的 Ticket 數量，避免並行過多 |
| **時間盒** | Timebox | 為 Ticket 設定時間限制，避免執行時間過長 |
| **自我檢查** | Self-Review | 開發者提交 Review 前的自我驗收檢查 |
| **修正循環** | Rework Loop | Review 未通過時返回「進行中」狀態進行修正的循環 |
| **技術債務** | Technical Debt | 暫時性解決方案、遺留 TODO、已知問題等未來需處理的項目 |

---

## 附錄 B：快速參考表

### Ticket 狀態流轉快速參考

| 當前狀態 | 可流轉到 | 觸發條件 | 執行動作 |
|---------|---------|---------|---------|
| **待執行** | 進行中 | 開發者領取 | 標記為「進行中」，記錄開始時間 |
| **進行中** | Review 中 | 完成執行，自我檢查通過 | 標記為「Review 中」，通知 Reviewer |
| **進行中** | 待執行 | 遇到阻塞問題 | 記錄暫停原因，等待問題解決 |
| **Review 中** | 已完成 | Review 通過 | 標記為「已完成」，更新工作日誌 |
| **Review 中** | 進行中 | Review 未通過 | 記錄 Review 意見，執行修正 |

### Ticket 建立快速檢查表

| 檢查項目 | 標準 | 檢查方式 |
|---------|------|---------|
| **標題格式** | `Ticket #N: [動詞] [目標]` | 包含動詞和具體目標 |
| **背景欄位** | 說明需求來源和上下文 | 連結到需求文檔 |
| **目標欄位** | 一句話明確目標（≤ 30 字）| 可客觀驗證 |
| **步驟欄位** | 3-5 個具體可操作步驟 | 開發者可按步驟執行 |
| **驗收條件** | 3-5 個 SMART 條件 | 客觀可檢查，使用 checkbox |
| **參考文件** | 連結設計和需求文檔 | 提供完整資訊 |

### SMART 驗收條件快速參考

| SMART | 中文 | 關鍵檢查 | 範例（✅ 良好 / ❌ 不良）|
|-------|------|---------|----------------------|
| **S** | 具體 | 避免模糊用語 | ✅ `dart analyze` 0 錯誤 / ❌ 程式碼品質良好 |
| **M** | 可測量 | 使用數字、百分比 | ✅ 測試覆蓋率 ≥ 80% / ❌ 測試覆蓋率高 |
| **A** | 可達成 | 範圍合理 | ✅ 整合 Google Books API / ❌ 整合所有第三方 API |
| **R** | 相關 | 與目標直接相關 | ✅ Repository 測試通過 / ❌ UI 顏色符合規範 |
| **T** | 明確完成標準 | 知道何時算完成 | ✅ 覆蓋率 ≥ 80% 達標 / ❌ 持續提高覆蓋率 |

### Ticket 關閉快速檢查表

| 條件類型 | 條件內容 | 檢查方式 |
|---------|---------|---------|
| **強制 1** | 所有驗收條件打勾完成 | 逐項檢查 checkbox |
| **強制 2** | Review 通過 | Reviewer 確認 |
| **強制 3** | 相關測試 100% 通過 | 執行 `flutter test` |
| **強制 4** | dart analyze 0 錯誤 | 執行 `dart analyze` |
| **強制 5** | 工作日誌已更新 | 檢查工作日誌 Ticket 索引 |
| **建議 1** | 程式碼符合專案規範 | 使用 Code Review Checklist |
| **建議 2** | 無技術債務產生 | 搜尋 TODO / FIXME |
| **建議 3** | 文檔同步更新 | 檢查 API 文檔、使用者文檔 |

---

## 附錄 C：與其他方法論的整合指引

本方法論與其他專案方法論緊密整合，共同構成完整的開發流程體系。

### 整合 1：與「Ticket 拆分標準方法論」整合

**整合點**：Ticket 建立階段

**整合方式**：

1. **拆分方法論負責**：
   - 評估任務複雜度
   - 決定拆分策略（按層級、按模組、按步驟）
   - 產出多個獨立 Ticket

2. **生命週期方法論負責**：
   - 使用統一 Ticket 建立模板
   - 確保每個 Ticket 符合建立標準
   - 設定 Ticket 間的依賴關係

**完整流程**：

```text
大任務
  ↓
[Ticket 拆分標準方法論]
  - 評估複雜度
  - 決定拆分策略
  - 拆分為多個 Ticket
  ↓
多個獨立 Ticket
  ↓
[Ticket 生命週期管理方法論]
  - 使用建立模板
  - 填寫 5 個核心欄位
  - 設定依賴關係
  - 設定 SMART 驗收條件
  ↓
準備就緒的 Ticket（待執行狀態）
```

**參考文件**：`.claude/methodologies/ticket-splitting-standard-methodology.md`

---

### 整合 2：與「Code Smell 品質閘門檢測方法論」整合

**整合點**：Ticket Review 階段

**整合方式**：

1. **生命週期方法論負責**：
   - Ticket 完成後提交 Review
   - 等待 Review 結果

2. **品質閘門方法論負責**：
   - 執行 C1/C2/C3 品質檢測
   - 判定通過/警告/阻止
   - 提供修正建議

**完整流程**：

```text
Ticket 進行中
  ↓
  開發者完成執行
  ↓
[生命週期方法論]
  - 自我檢查
  - 提交 Review
  ↓
Review 中
  ↓
[Code Smell 品質閘門方法論]
  - C1 檢測（複雜度）
  - C2 檢測（完整性）
  - C3 檢測（責任明確性）
  ↓
  通過？
    ├─ Yes → 已完成
    └─ No  → 進行中（修正）
```

**參考文件**：`.claude/methodologies/code-smell-quality-gate-methodology.md`

---

### 整合 3：與「Ticket 設計派工方法論」整合

**整合點**：Ticket 規劃和派工階段

**整合方式**：

1. **設計派工方法論負責**：
   - 專案整體規劃
   - Ticket 優先級排序
   - 開發者工作分配

2. **生命週期方法論負責**：
   - 領取 Ticket 流程
   - 執行進度追蹤
   - 狀態流轉管理

**完整流程**：

```text
專案需求
  ↓
[Ticket 設計派工方法論]
  - 整體規劃
  - 優先級排序
  - 開發者分配
  ↓
待執行 Ticket 列表
  ↓
[生命週期方法論]
  - 開發者領取 Ticket
  - 執行流程六步驟
  - 狀態流轉管理
  - 完成後關閉
  ↓
已完成 Ticket
```

**參考文件**：`.claude/methodologies/ticket-design-dispatch-methodology.md`

---

### 整合 4：與「敏捷重構方法論」整合

**整合點**：整個開發流程

**整合方式**：

1. **敏捷重構方法論負責**：
   - TDD 四階段流程
   - Agent 分工協作
   - 三重文件管理

2. **生命週期方法論負責**：
   - 每個 Ticket 的具體執行
   - 狀態追蹤和進度管理
   - 驗收和關閉標準

**完整流程**：

```text
[敏捷重構方法論]
  Phase 1: 設計
    ↓
    [生命週期方法論] 建立設計 Ticket，執行並完成
    ↓
  Phase 2: 測試
    ↓
    [生命週期方法論] 建立測試 Ticket，執行並完成
    ↓
  Phase 3: 實作
    ↓
    [生命週期方法論] 建立實作 Ticket，執行並完成
    ↓
  Phase 4: 重構
    ↓
    [生命週期方法論] 建立重構 Ticket，執行並完成
    ↓
  功能完成
```

**參考文件**：`.claude/methodologies/agile-refactor-methodology.md`

---

### 完整整合流程圖

```text
專案需求
  ↓
[Ticket 設計派工方法論] 整體規劃
  ↓
大任務
  ↓
[Ticket 拆分標準方法論] 拆分策略
  ↓
多個獨立 Ticket
  ↓
[Ticket 生命週期管理方法論] 建立標準
  ↓
待執行 Ticket
  ↓
[敏捷重構方法論] TDD 四階段
  ├─ Phase 1: 設計 Ticket
  ├─ Phase 2: 測試 Ticket
  ├─ Phase 3: 實作 Ticket
  └─ Phase 4: 重構 Ticket
  ↓
[生命週期方法論] 執行流程
  - 領取 → 執行 → Review → 關閉
  ↓
[Code Smell 品質閘門方法論] Review 檢測
  - C1/C2/C3 檢測
  ↓
已完成 Ticket
```

---

## 總結

### 方法論價值

本方法論建立**完整的 Ticket 生命週期管理體系**，提供：

1. **清晰的狀態模型**：4 個狀態和明確的流轉規則
2. **標準化建立流程**：統一模板和 5 個核心欄位
3. **系統化執行流程**：6 個步驟從領取到關閉
4. **客觀的驗收標準**：SMART 原則確保可測量
5. **嚴謹的關閉條件**：5 項強制條件保證完整性

### 核心創新

本方法論的核心創新在於：

**系統化 + 標準化 + 可追溯**

- **系統化**：完整的生命週期管理，從建立到關閉無遺漏
- **標準化**：統一的模板、格式、流程，確保一致性
- **可追溯**：完整的狀態記錄、執行日誌、完成記錄

### 適用場景

本方法論特別適用於：

- 敏捷開發團隊需要明確的任務管理
- 遠端協作團隊需要清晰的狀態和標準
- 大型專案需要系統化的 Ticket 管理
- 品質要求嚴格的專案需要完整驗收

### 持續改進建議

1. **定期檢視流程**：每月檢視 Ticket 生命週期指標（週期時間、返工率）
2. **團隊回顧會議**：分享 Ticket 執行經驗，識別流程改進機會
3. **模板持續優化**：根據實務經驗調整 Ticket 建立模板
4. **驗收條件庫**：建立常用 SMART 驗收條件範例庫
5. **自動化檢查**：開發工具自動檢查 Ticket 格式和關閉條件

---

**文件結束**

本方法論提供完整的 Ticket 生命週期管理指引，涵蓋狀態定義、建立標準、執行流程、驗收標準、關閉條件和最佳實踐。與其他專案方法論緊密整合，共同構成完整的敏捷開發流程體系。

建議配合以下文件使用：
- Ticket 拆分標準方法論（拆分策略）
- Code Smell 品質閘門檢測方法論（品質檢測）
- Ticket 設計派工方法論（整體規劃）
- 敏捷重構方法論（TDD 流程）
