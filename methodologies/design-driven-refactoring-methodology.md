# 設計驅動重構方法論：Domain Root 檢查與技術債務清理實戰指南

## 📋 概述

本文記錄了基於設計文件檢查、測試驗證、程式實作的完整重構方法論，以 Book 和 Library 兩個 Domain Root 的重構為實戰案例，提供系統化的問題識別和修復策略。

## 🎯 設計驅動重構核心原則

### 1. 設計文件優先原則
**核心思想**: 所有重構決策必須基於現有設計文件和需求規格

```markdown
檢查順序：
1. 應用程式需求規格書 (docs/app-requirements-spec.md)
2. 用例說明文件 (docs/app-use-cases.md)
3. UI 設計規格書 (docs/ui_design_specification.md)
4. 錯誤處理設計 (docs/app-error-handling-design.md)
5. 測試指導原則 (test/TESTING_GUIDELINES.md)
6. 工作日誌記錄 (docs/work-logs/*.md)
```

### 2. 三階段驗證流程
**階段1: 設計文件檢查** → **階段2: 測試覆蓋率分析** → **階段3: 程式實作驗證**

## 🔍 實戰案例：Book & Library Domain Root 檢查

### 階段1: 設計文件檢查結果

#### Book 實體設計驗證
```text
✅ 符合 DDD 設計原則
✅ 聚合根功能完整
✅ 需求追蹤連結存在
⚠️ 技術債務：author 欄位標記為需要重構
```

#### Library 實體設計驗證
```text
✅ 聚合根架構正確
✅ 統計功能設計完整
⚠️ 混合領域物件問題
⚠️ 異常處理不統一
```

### 階段2: 測試覆蓋率分析結果

#### 測試架構問題發現
```text
🚨 嚴重問題：
- book_test.dart 使用 flutter_test 套件（應為純 test）
- library_domain_test.dart 包含大量跳過的測試
- 測試無法在純 Dart 環境執行

📊 覆蓋率問題：
- Book 實體：部分測試包含 fail() 調用
- Library 實體：複雜業務邏輯測試不足
```

### 階段3: 程式實作驗證結果

#### Book 實體實作問題
```text
🔴 技術債務確認：
- author 欄位使用 String 類型（應為 BookAuthor Value Object）
- 缺乏多作者和譯者支援
- 搜尋和比較功能受限

🟡 註解完整性：
- 缺乏完整的 REQ-LIB-XXX 需求追蹤
- 業務規則說明不足
```

#### Library 實體實作問題
```text
🔴 嚴重類型錯誤：
- 使用不存在的 ReadingStatus 枚舉值（'digital', 'borrowed'）
- 統計計算邏輯基於錯誤的枚舉假設

🔴 異常處理問題：
- 使用自定義異常類別（DuplicateBookException 等）
- 未遵循專案 AppError 體系標準

🔴 檔案結構混亂：
- 一個檔案混合聚合根、Value Objects、服務類別
- 違反 DDD 分層原則
```

## 🛠️ 系統化重構執行策略

### 重構優先級矩陣

| 問題類型 | 影響範圍 | 修復優先級 | 修復策略 |
|---------|---------|-----------|---------|
| 類型系統錯誤 | 整個系統 | 🔴 立即 | 修正枚舉使用，確保類型安全 |
| 異常處理不統一 | 錯誤管理 | 🔴 立即 | 統一為 AppError 體系 |
| 技術債務 | 功能擴充 | 🟡 短期 | 重構為 Value Object |
| 註解不完整 | 可維護性 | 🟢 中期 | 補充完整業務註解 |
| 測試架構 | 品質保證 | 🟡 短期 | 修正測試依賴問題 |

### 重構執行流程

#### 第一階段：緊急修復
```text
1. 類型系統錯誤修復
   - 識別所有錯誤枚舉使用
   - 修正為正確的 SourceType 判斷
   - 驗證編譯通過

2. 異常處理統一
   - 移除自定義異常類別
   - 重構為 AppError 體系
   - 保持 OperationResult 模式
```

#### 第二階段：架構改善
```text
1. 技術債務清理
   - 建立 BookAuthor Value Object
   - 重構 Book.author 欄位
   - 更新所有相關使用處

2. 註解體系建立
   - 建立 REQ-LIB-XXX 需求編號
   - 補充完整業務規則說明
   - 添加維護指引和約束條件
```

#### 第三階段：品質驗證
```text
1. 編譯檢查
   - dart analyze 無錯誤
   - 類型安全性驗證
   - 向後相容性確認

2. 功能驗證
   - 核心功能正常運作
   - API 介面保持不變
   - 測試邏輯適配完成
```

## 📊 實戰成果分析

### 修復效果統計

#### Book 實體重構成果
```text
📝 註解覆蓋率: 0% → 100% (27個業務函式)
🔧 技術債務: 1個 → 0個 (BookAuthor 重構完成)
⚡ 功能增強: 支援多作者、譯者解析、豐富搜尋
📋 需求追蹤: 建立完整 REQ-LIB-XXX 體系
```

#### Library 實體重構成果
```text
🐛 類型錯誤: 6個 → 0個 (枚舉使用修正)
🔧 異常處理: 統一為 AppError 體系
📝 註解覆蓋率: 0% → 100% (37個 REQ-LIB-XXX)
⚡ 統計功能: 所有空實作 → 完整可用
```

#### 系統整體改善
```text
📁 修復檔案: 35+ 個檔案
🔍 編譯錯誤: 24個 → 0個
🏗️ 架構一致性: 大幅提升
🧪 測試相容性: 完全適配
```

## 🚨 重構過程中發現的典型問題模式

### 1. 類型系統問題模式
```dart
// ❌ 常見錯誤：使用不存在的枚舉值
books.where((book) => book.readingStatus == 'digital')

// ✅ 正確方式：使用正確的類型判斷
books.where((book) => book.source.type.isDigital)
```

### 2. 異常處理問題模式
```dart
// ❌ 舊式自定義異常
throw DuplicateBookException('message', bookId: id, title: title);

// ✅ 新式 AppError 體系
return OperationResult.failure(
  BusinessLogicError(
    message: 'message',
    businessRule: 'BOOK_DUPLICATE_PREVENTION',
    code: ErrorCodes.duplicateBook,
    context: {'bookId': id, 'title': title},
  ),
  'userMessage'
);
```

### 3. Value Object 重構模式
```dart
// ❌ 原始 String 類型
final String author;

// ✅ 強類型 Value Object
final BookAuthor author;

// 轉換策略：
String → BookAuthor: BookAuthor.fromString(stringValue)
BookAuthor → String: bookAuthor.displayValue
```

## 📋 檢查清單：未來 Domain Root 檢查要點

### 設計文件檢查清單
- [ ] 實體是否符合 DDD 聚合根設計
- [ ] 業務邏輯是否有完整的需求追蹤
- [ ] 錯誤處理是否遵循專案標準
- [ ] Value Objects 是否設計合理
- [ ] 工廠方法是否提供足夠的建立選項

### 測試架構檢查清單
- [ ] 測試檔案是否使用正確的測試套件
- [ ] Domain 測試是否可在純 Dart 環境執行
- [ ] 測試覆蓋率是否達到業務邏輯要求
- [ ] 是否有跳過或失敗的測試需要修復
- [ ] 測試資料建立是否遵循 DDD 原則

### 程式實作檢查清單
- [ ] 類型系統是否一致且安全
- [ ] 枚舉使用是否正確
- [ ] 異常處理是否統一
- [ ] 檔案結構是否符合 DDD 分層
- [ ] 註解是否完整且有業務意義
- [ ] API 是否保持向後相容性

### 技術債務識別清單
- [ ] TODO 註解是否有具體的修復計畫
- [ ] String 類型是否應重構為 Value Object
- [ ] 方法職責是否單一且清晰
- [ ] 是否存在重複的業務邏輯
- [ ] 錯誤處理是否完整且一致

## 🎯 重構成功關鍵因素

### 1. 完整的問題識別
**策略**: 三階段檢查確保不遺漏任何設計債務
**工具**: 設計文件對照、測試執行、編譯檢查

### 2. 系統化的修復順序
**原則**: 先修復影響範圍大的問題，再處理局部改善
**實踐**: 類型錯誤 → 異常處理 → 技術債務 → 註解補充

### 3. 漸進式的重構策略
**方法**: 保持向後相容性，分階段完成改善
**驗證**: 每個階段都要確保編譯通過和功能正常

### 4. 完整的驗證機制
**檢查**: 編譯檢查、功能測試、API 相容性驗證
**標準**: 100% 編譯通過、完整功能保持、測試適配完成

## 📚 經驗總結與建議

### 重構前準備工作
1. **設計文件研讀**: 確保理解完整的業務需求和架構設計
2. **測試狀況調查**: 了解現有測試的覆蓋範圍和品質
3. **依賴關係分析**: 識別會受影響的檔案和模組
4. **影響範圍評估**: 制定完整的修復計畫和優先級

### 重構執行原則
1. **小步快跑**: 每次只修復一類問題，確保可控制的變更範圍
2. **測試先行**: 確保每次修改後都能通過編譯和基本功能驗證
3. **文檔同步**: 重要修改要更新對應的設計文件和註解
4. **版本追蹤**: 記錄重構過程和決策，便於後續維護

### 品質控制要點
1. **類型安全**: 確保所有類型使用正確且一致
2. **功能完整**: 重構不可破壞現有功能
3. **架構一致**: 遵循專案的設計原則和模式
4. **可維護性**: 提升程式碼的可讀性和擴充性

## 🔧 工具和方法

### 檢查工具
- `dart analyze`: 編譯檢查和靜態分析
- `grep/ripgrep`: 程式碼模式搜尋
- 專案文件對照: 設計規範一致性檢查

### 重構代理工具
- `cinnamon-refactor-owl`: TDD Phase 4 重構專家
- 系統化批量修復: 確保一致性和完整性
- 自動化驗證: 減少人為疏漏

### 驗證方法
- 編譯檢查: 確保類型安全
- 功能測試: 驗證業務邏輯正確
- API 相容性: 保持向後相容性
- 文檔更新: 同步維護設計文件

---

本方法論基於 v0.8.25-v0.8.26 的實戰重構經驗，提供了完整的設計驅動重構流程，可作為未來類似工作的參考指南。
